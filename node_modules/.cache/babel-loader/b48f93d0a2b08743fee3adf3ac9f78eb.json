{"remainingRequest":"/Users/marceltanner/Google Drive/Kreativs/Interaktiv/Self Driving/vue_2_selfdriving/node_modules/thread-loader/dist/cjs.js!/Users/marceltanner/Google Drive/Kreativs/Interaktiv/Self Driving/vue_2_selfdriving/node_modules/babel-loader/lib/index.js!/Users/marceltanner/Google Drive/Kreativs/Interaktiv/Self Driving/vue_2_selfdriving/node_modules/cache-loader/dist/cjs.js??ref--1-0!/Users/marceltanner/Google Drive/Kreativs/Interaktiv/Self Driving/vue_2_selfdriving/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/marceltanner/Google Drive/Kreativs/Interaktiv/Self Driving/vue_2_selfdriving/src/App.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/marceltanner/Google Drive/Kreativs/Interaktiv/Self Driving/vue_2_selfdriving/src/App.vue","mtime":1662140713216},{"path":"/Users/marceltanner/Google Drive/Kreativs/Interaktiv/Self Driving/vue_2_selfdriving/babel.config.js","mtime":1644164865878},{"path":"/Users/marceltanner/Google Drive/Kreativs/Interaktiv/Self Driving/vue_2_selfdriving/node_modules/cache-loader/dist/cjs.js","mtime":1644164856547},{"path":"/Users/marceltanner/Google Drive/Kreativs/Interaktiv/Self Driving/vue_2_selfdriving/node_modules/thread-loader/dist/cjs.js","mtime":1644164856547},{"path":"/Users/marceltanner/Google Drive/Kreativs/Interaktiv/Self Driving/vue_2_selfdriving/node_modules/babel-loader/lib/index.js","mtime":1644164857550},{"path":"/Users/marceltanner/Google Drive/Kreativs/Interaktiv/Self Driving/vue_2_selfdriving/node_modules/cache-loader/dist/cjs.js","mtime":1644164856547},{"path":"/Users/marceltanner/Google Drive/Kreativs/Interaktiv/Self Driving/vue_2_selfdriving/node_modules/vue-loader/lib/index.js","mtime":1644164857852}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0IF90b0NvbnN1bWFibGVBcnJheSBmcm9tICIvVXNlcnMvbWFyY2VsdGFubmVyL0dvb2dsZSBEcml2ZS9LcmVhdGl2cy9JbnRlcmFrdGl2L1NlbGYgRHJpdmluZy92dWVfMl9zZWxmZHJpdmluZy9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdG9Db25zdW1hYmxlQXJyYXkuanMiOwppbXBvcnQgX29iamVjdFNwcmVhZCBmcm9tICIvVXNlcnMvbWFyY2VsdGFubmVyL0dvb2dsZSBEcml2ZS9LcmVhdGl2cy9JbnRlcmFrdGl2L1NlbGYgRHJpdmluZy92dWVfMl9zZWxmZHJpdmluZy9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0U3ByZWFkMi5qcyI7CmltcG9ydCBfYXN5bmNUb0dlbmVyYXRvciBmcm9tICIvVXNlcnMvbWFyY2VsdGFubmVyL0dvb2dsZSBEcml2ZS9LcmVhdGl2cy9JbnRlcmFrdGl2L1NlbGYgRHJpdmluZy92dWVfMl9zZWxmZHJpdmluZy9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vYXN5bmNUb0dlbmVyYXRvci5qcyI7CmltcG9ydCAicmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuc2xpY2UuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5maW5kLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZy5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmZ1bmN0aW9uLm5hbWUuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5zb3J0LmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZmlsbC5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC50by1zdHJpbmcuanMiOwoKLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KdmFyIHRmID0gcmVxdWlyZSgnQHRlbnNvcmZsb3cvdGZqcycpOwoKZXhwb3J0IGRlZmF1bHQgewogIG5hbWU6ICdBcHAnLAogIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7CiAgICByZXR1cm4gewogICAgICBjdHg6IG51bGwsCiAgICAgIHdvcmxkV2lkdGg6IDI1NiwKICAgICAgd29ybGRIZWlnaHQ6IDI1NiwKICAgICAgaW1nV29ybGQ6IG51bGwsCiAgICAgIHdvcmxkTG9hZGVkOiBmYWxzZSwKICAgICAgZnBzOiBudWxsLAogICAgICBmcHNDb3VudGVyOiBudWxsLAogICAgICB0aWNrOiB0cnVlLAogICAgICB0aWNrVGltZTogbnVsbCwKICAgICAgZHVyYXRpb246IC0xLAogICAgICBkdXJhdGlvblN0cmluZzogbnVsbCwKICAgICAgY2FyOiB7CiAgICAgICAgd2lkdGg6IDgsCiAgICAgICAgbGVuZ3RoOiAxNiwKICAgICAgICB4OiAyNTYgLyAyICogMC4yNSwKICAgICAgICB5OiAyNTYgLyAyICogMS41LAogICAgICAgIHNwZWVkOiAwLjUsCiAgICAgICAgc3RlZXJpbmdTcGVlZDogMC4wMjUsCiAgICAgICAgYW5nbGU6IDAKICAgICAgfSwKICAgICAgdmlld1NpemU6IDMyLAogICAgICB2aWV3UmVkdWN0aW9uOiA0LAogICAgICB2aWV3UmVkdWNlZFNpemU6IG51bGwsCiAgICAgIHZpZXdQaXhlbHM6IG51bGwsCiAgICAgIHN0ZWVyaW5nOiBudWxsLAogICAgICBzYW1wbGVzOiBbXSwKICAgICAgc2FtcGxlc01heExlbmd0aDogNDA5NiwKICAgICAgdHJhaW5pbmdTYW1wbGVzOiBudWxsLAogICAgICB0cmFpbmluZ1NhbXBsZXNNYXhMZW5ndGg6IDQwOTYsCiAgICAgIGJhZFJld2FyZHM6IDAsCiAgICAgIGJhZFJld2FyZHNJbkFSb3c6IDAsCiAgICAgIHNjb3JlOiAwLAogICAgICBsYXN0U2NvcmU6IG51bGwsCiAgICAgIGhpZ2hzY29yZXM6IFtdLAogICAgICBoaWdoc2NvcmVzTWF4TGVuZ3RoOiAxMCwKICAgICAgaGlnaHNjb3Jlc01heFNob3duOiAxMCwKICAgICAgdHJhaW5pbmc6IGZhbHNlLAogICAgICB0cmFpbmluZ1Byb2dyZXNzOiAwLAogICAgICBtb2RlbHM6IHVuZGVmaW5lZCwKICAgICAgbnVtYmVyT2ZNb2RlbHM6IDUsCiAgICAgIG1vZGVsSW5kZXg6IDAKICAgIH07CiAgfSwKICBjb21wdXRlZDogewogICAgcmVkdWNlZFZpZXdTaXplOiBmdW5jdGlvbiByZWR1Y2VkVmlld1NpemUoKSB7CiAgICAgIHZhciByZWR1Y2VkU2l6ZSA9IHRoaXMudmlld1NpemU7CgogICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudmlld1JlZHVjdGlvbjsgaSsrKSB7CiAgICAgICAgcmVkdWNlZFNpemUgPSByZWR1Y2VkU2l6ZSAvIDI7CiAgICAgIH0KCiAgICAgIHJldHVybiByZWR1Y2VkU2l6ZTsKICAgIH0sCiAgICBoaWdoc2NvcmVzU2hvd246IGZ1bmN0aW9uIGhpZ2hzY29yZXNTaG93bigpIHsKICAgICAgcmV0dXJuIHRoaXMuaGlnaHNjb3Jlcy5zbGljZSgwLCB0aGlzLmhpZ2hzY29yZXNNYXhTaG93bik7CiAgICB9CiAgfSwKICBtb3VudGVkOiBmdW5jdGlvbiBtb3VudGVkKCkgewogICAgdGhpcy5jdHggPSB0aGlzLiRyZWZzLmNhbnZhcy5nZXRDb250ZXh0KCIyZCIpOwogICAgdGhpcy5pbWdXb3JsZCA9IG5ldyBJbWFnZSh0aGlzLndvcmxkV2lkdGgsIHRoaXMud29ybGRIZWlnaHQpOwogICAgdGhpcy5pbWdXb3JsZC5zcmMgPSByZXF1aXJlKCcvc3JjL2Fzc2V0cy93b3JsZDQuanBnJyk7CiAgICB2YXIgYXBwID0gdGhpczsKCiAgICB0aGlzLmltZ1dvcmxkLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHsKICAgICAgYXBwLndvcmxkTG9hZGVkID0gdHJ1ZTsKICAgIH07IC8vZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMua2V5RG93bik7CiAgICAvL2RvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgdGhpcy5rZXlVcCk7CgoKICAgIHRoaXMuY3R4Vmlld1NuYXBzaG90ID0gdGhpcy4kcmVmcy52aWV3U25hcHNob3RDYW52YXMuZ2V0Q29udGV4dCgiMmQiKTsKICAgIHRoaXMuY3R4Q2FyU25hcHNob3QgPSB0aGlzLiRyZWZzLmNhclNuYXBzaG90Q2FudmFzLmdldENvbnRleHQoIjJkIik7CiAgICB0aGlzLmN0eENhciA9IHRoaXMuJHJlZnMuY2FyQ2FudmFzLmdldENvbnRleHQoIjJkIik7CiAgICB0aGlzLmN0eFZpZXcgPSB0aGlzLiRyZWZzLnZpZXdDYW52YXMuZ2V0Q29udGV4dCgiMmQiKTsKICAgIHRoaXMuY3R4Vmlld1JlZHVjZWQgPSB0aGlzLiRyZWZzLnZpZXdDYW52YXNSZWR1Y2VkLmdldENvbnRleHQoIjJkIik7CiAgICB0aGlzLmN0eFN0YXRzID0gdGhpcy4kcmVmcy5zdGF0c0NhbnZhcy5nZXRDb250ZXh0KCIyZCIpOwogICAgdGhpcy52aWV3UmVkdWNlZFNpemUgPSB0aGlzLnZpZXdTaXplOwoKICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy52aWV3UmVkdWN0aW9uOyBpKyspIHsKICAgICAgdGhpcy52aWV3UmVkdWNlZFNpemUgPSB0aGlzLnZpZXdSZWR1Y2VkU2l6ZSAvIDI7CiAgICB9CgogICAgdGhpcy5tb2RlbHMgPSBuZXcgQXJyYXkodGhpcy5udW1iZXJPZk1vZGVscyk7CiAgICB0aGlzLmNyZWF0ZU1vZGVsKHRoaXMubW9kZWxJbmRleCk7CiAgICB0aGlzLnJlZnJlc2hMb29wKCk7CiAgfSwKICBtZXRob2RzOiB7CiAgICBjcmVhdGVNb2RlbDogZnVuY3Rpb24gY3JlYXRlTW9kZWwobW9kZWxJbmRleCkgewogICAgICBjb25zb2xlLmxvZygiY3JlYXRpbmcgbW9kZWwgLi4uIik7CiAgICAgIHZhciBudW1iZXJPZkxheWVycyA9IDI7CiAgICAgIHZhciBsYXllcnMgPSBuZXcgQXJyYXkobnVtYmVyT2ZMYXllcnMpOwoKICAgICAgZm9yICh2YXIgaSA9IG51bWJlck9mTGF5ZXJzIC0gMTsgaSA+PSAwOyBpLS0pIHsKICAgICAgICBpZiAoaSA9PT0gbnVtYmVyT2ZMYXllcnMgLSAxKSB7CiAgICAgICAgICAvLyBsYXN0IGxheWVyCiAgICAgICAgICBsYXllcnNbaV0gPSB7CiAgICAgICAgICAgIHVuaXRzOiAxLAogICAgICAgICAgICBhY3RpdmF0aW9uOiAic2lnbW9pZCIKICAgICAgICAgIH07CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGxheWVyc1tpXSA9IHsKICAgICAgICAgICAgdW5pdHM6IDMgKyBNYXRoLmNlaWwoTWF0aC5yYW5kb20oKSAqIDE1KSwKICAgICAgICAgICAgYWN0aXZhdGlvbjogWyJyZWx1IiwgInNpZ21vaWQiXVtNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkpXQogICAgICAgICAgfTsKICAgICAgICB9CiAgICAgIH0KCiAgICAgIHRoaXMubW9kZWxzW21vZGVsSW5kZXhdID0gewogICAgICAgIGxheWVyczogbGF5ZXJzLAogICAgICAgIHRyYWluaW5nczogMCwKICAgICAgICBoaWdoc2NvcmU6IHVuZGVmaW5lZCwKICAgICAgICBuYW1lOiBtb2RlbEluZGV4ICsgMSwKICAgICAgICBjaGlsZHJlbjogMAogICAgICB9OyAvLyBjcmVhdGUgbW9kZWwgd2l0aCBsYXllcnMKCiAgICAgIHRoaXMubW9kZWxzW21vZGVsSW5kZXhdLm1vZGVsID0gdGYuc2VxdWVudGlhbCgpOwoKICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGxheWVycy5sZW5ndGg7IF9pKyspIHsKICAgICAgICBpZiAoX2kgPT09IDApIHsKICAgICAgICAgIC8vIGZpcnN0IGxheWVyCiAgICAgICAgICB0aGlzLm1vZGVsc1ttb2RlbEluZGV4XS5tb2RlbC5hZGQodGYubGF5ZXJzLmRlbnNlKHsKICAgICAgICAgICAgaW5wdXRTaGFwZTogdGhpcy52aWV3UmVkdWNlZFNpemUgKiB0aGlzLnZpZXdSZWR1Y2VkU2l6ZSwKICAgICAgICAgICAgYWN0aXZhdGlvbjogbGF5ZXJzW19pXS5hY3RpdmF0aW9uLAogICAgICAgICAgICB1bml0czogbGF5ZXJzW19pXS51bml0cwogICAgICAgICAgfSkpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICB0aGlzLm1vZGVsc1ttb2RlbEluZGV4XS5tb2RlbC5hZGQodGYubGF5ZXJzLmRlbnNlKHsKICAgICAgICAgICAgYWN0aXZhdGlvbjogbGF5ZXJzW19pXS5hY3RpdmF0aW9uLAogICAgICAgICAgICB1bml0czogbGF5ZXJzW19pXS51bml0cwogICAgICAgICAgfSkpOwogICAgICAgIH0KICAgICAgfQogICAgICAvKgogICAgICB0aGlzLm1vZGVsc1tpXS5tb2RlbC5hZGQodGYubGF5ZXJzLmRlbnNlKHtpbnB1dFNoYXBlOiB0aGlzLnZpZXdSZWR1Y2VkU2l6ZSp0aGlzLnZpZXdSZWR1Y2VkU2l6ZSwgYWN0aXZhdGlvbjogInJlbHUiLCB1bml0czogMTB9KSk7CiAgICAgIHRoaXMubW9kZWxzW2ldLm1vZGVsLmFkZCh0Zi5sYXllcnMuZGVuc2Uoe2FjdGl2YXRpb246ICJyZWx1IiwgdW5pdHM6IDV9KSk7CiAgICAgIHRoaXMubW9kZWxzW2ldLm1vZGVsLmFkZCh0Zi5sYXllcnMuZGVuc2Uoe2FjdGl2YXRpb246ICJzaWdtb2lkIiwgdW5pdHM6IDF9KSk7CiAgICAgICovCiAgICAgIC8vdGhpcy5tb2RlbHNbaV0uYWRkKHRmLmxheWVycy5kZW5zZSh7YWN0aXZhdGlvbjogInJlbHUiLCB1bml0czogMX0pKTsKCgogICAgICB0aGlzLm1vZGVsc1ttb2RlbEluZGV4XS5tb2RlbC5jb21waWxlKHsKICAgICAgICBsb3NzOiAnYmluYXJ5Q3Jvc3NlbnRyb3B5JywKICAgICAgICBvcHRpbWl6ZXI6IHRmLnRyYWluLnJtc3Byb3AoMC4xKSwKICAgICAgICBtZXRyaWNzOiBbJ2FjY3VyYWN5J10KICAgICAgfSk7IC8vdGhpcy5tb2RlbC5jb21waWxlKHtsb3NzOidjYXRlZ29yaWNhbENyb3NzZW50cm9weScsb3B0aW1pemVyOnRmLnRyYWluLmFkYW0oKSxtZXRyaWNzOlsnYWNjdXJhY3knXX0pOwogICAgfSwKICAgIHRyYWluOiBmdW5jdGlvbiB0cmFpbigpIHsKICAgICAgdmFyIF90aGlzID0gdGhpczsKCiAgICAgIHJldHVybiBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoKSB7CiAgICAgICAgdmFyIGhpZ2hzY29yZU9mTW9kZWwsIF9oaWdoc2NvcmVPZk1vZGVsLCByYW5kb20sIGhpZ2hzY29yZUluZGV4LCBtb3RoZXIsIGksIF90aGlzJHRyYWluaW5nU2FtcGxlcywgc2FtcGxlcywgaiwgZmVhdHVyZVZhbHVlc1RyYWluaW5nLCBsYWJlbFZhbHVlc1RyYWluaW5nLCBfaTIsIGZlYXR1cmVWYWx1ZVRyYWluaW5nLCBmZWF0dXJlVGVuc29yVHJhaW5pbmcsIGxhYmVsVGVuc29yVHJhaW5pbmc7CgogICAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkgewogICAgICAgICAgd2hpbGUgKDEpIHsKICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkgewogICAgICAgICAgICAgIGNhc2UgMDoKICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIG5ldyBoaWdoc2NvcmU6CiAgICAgICAgICAgICAgICBoaWdoc2NvcmVPZk1vZGVsID0gX3RoaXMuaGlnaHNjb3Jlcy5maW5kKGZ1bmN0aW9uIChlbCkgewogICAgICAgICAgICAgICAgICByZXR1cm4gZWwubW9kZWxJbmRleCA9PT0gX3RoaXMubW9kZWxJbmRleDsKICAgICAgICAgICAgICAgIH0pOwoKICAgICAgICAgICAgICAgIGlmIChoaWdoc2NvcmVPZk1vZGVsKSB7CiAgICAgICAgICAgICAgICAgIF90aGlzLm1vZGVsc1tfdGhpcy5tb2RlbEluZGV4XS5oaWdoc2NvcmUgPSBoaWdoc2NvcmVPZk1vZGVsLnNjb3JlOwogICAgICAgICAgICAgICAgfSAvLyBzd2l0Y2ggdG8gbmV4dCBtb2RlbAoKCiAgICAgICAgICAgICAgICBfdGhpcy5tb2RlbEluZGV4ID0gKF90aGlzLm1vZGVsSW5kZXggKyAxKSAlIF90aGlzLm51bWJlck9mTW9kZWxzOyAvLyBjcmVhdGUgb3IgbWFrZSBjbG9uZSwgaWYgbmVjZXNzYXJ5CgogICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5tb2RlbHNbX3RoaXMubW9kZWxJbmRleF0pIHsKICAgICAgICAgICAgICAgICAgX3RoaXMuY3JlYXRlTW9kZWwoX3RoaXMubW9kZWxJbmRleCk7CiAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAvLyBjaGVjayBmb3IgbmV3IGhpZ2hzY29yZQogICAgICAgICAgICAgICAgICBfaGlnaHNjb3JlT2ZNb2RlbCA9IF90aGlzLmhpZ2hzY29yZXMuZmluZChmdW5jdGlvbiAoZWwpIHsKICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWwubW9kZWxJbmRleCA9PT0gX3RoaXMubW9kZWxJbmRleDsKICAgICAgICAgICAgICAgICAgfSk7CgogICAgICAgICAgICAgICAgICBpZiAoIV9oaWdoc2NvcmVPZk1vZGVsKSB7CiAgICAgICAgICAgICAgICAgICAgLy8gcmVwbGFjZSBtb2RlbAogICAgICAgICAgICAgICAgICAgIHJhbmRvbSA9IE1hdGgucmFuZG9tKCk7CgogICAgICAgICAgICAgICAgICAgIGlmIChyYW5kb20gPiAxIC0gMC4xODIpIHsKICAgICAgICAgICAgICAgICAgICAgIGhpZ2hzY29yZUluZGV4ID0gMDsKICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHJhbmRvbSA+IDEgLSAwLjE4MiAtIDAuMTYzKSB7CiAgICAgICAgICAgICAgICAgICAgICBoaWdoc2NvcmVJbmRleCA9IDE7CiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChyYW5kb20gPiAxIC0gMC4xODIgLSAwLjE2MyAtIDAuMTQ2KSB7CiAgICAgICAgICAgICAgICAgICAgICBoaWdoc2NvcmVJbmRleCA9IDI7CiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChyYW5kb20gPiAxIC0gMC4xODIgLSAwLjE2MyAtIDAuMTQ2IC0gMC4xMjcpIHsKICAgICAgICAgICAgICAgICAgICAgIGhpZ2hzY29yZUluZGV4ID0gMzsKICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHJhbmRvbSA+IDEgLSAwLjE4MiAtIDAuMTYzIC0gMC4xNDYgLSAwLjEyNyAtIDAuMTA5KSB7CiAgICAgICAgICAgICAgICAgICAgICBoaWdoc2NvcmVJbmRleCA9IDQ7CiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChyYW5kb20gPiAxIC0gMC4xODIgLSAwLjE2MyAtIDAuMTQ2IC0gMC4xMjcgLSAwLjEwOSAtIDAuMDkxKSB7CiAgICAgICAgICAgICAgICAgICAgICBoaWdoc2NvcmVJbmRleCA9IDU7CiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChyYW5kb20gPiAxIC0gMC4xODIgLSAwLjE2MyAtIDAuMTQ2IC0gMC4xMjcgLSAwLjEwOSAtIDAuMDkxIC0gMC4wNzMpIHsKICAgICAgICAgICAgICAgICAgICAgIGhpZ2hzY29yZUluZGV4ID0gNjsKICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHJhbmRvbSA+IDEgLSAwLjE4MiAtIDAuMTYzIC0gMC4xNDYgLSAwLjEyNyAtIDAuMTA5IC0gMC4wOTEgLSAwLjA3MyAtIDAuMDU0KSB7CiAgICAgICAgICAgICAgICAgICAgICBoaWdoc2NvcmVJbmRleCA9IDc7CiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChyYW5kb20gPiAxIC0gMC4xODIgLSAwLjE2MyAtIDAuMTQ2IC0gMC4xMjcgLSAwLjEwOSAtIDAuMDkxIC0gMC4wNzMgLSAwLjA1NCAtIDAuMDM3KSB7CiAgICAgICAgICAgICAgICAgICAgICBoaWdoc2NvcmVJbmRleCA9IDg7CiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChyYW5kb20gPiAxIC0gMC4xODIgLSAwLjE2MyAtIDAuMTQ2IC0gMC4xMjcgLSAwLjEwOSAtIDAuMDkxIC0gMC4wNzMgLSAwLjA1NCAtIDAuMDM3IC0gMC4wMTgpIHsKICAgICAgICAgICAgICAgICAgICAgIGhpZ2hzY29yZUluZGV4ID0gOTsKICAgICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgICAgIG1vdGhlciA9IF90aGlzLm1vZGVsc1tfdGhpcy5oaWdoc2NvcmVzW2hpZ2hzY29yZUluZGV4XS5tb2RlbEluZGV4XTsKICAgICAgICAgICAgICAgICAgICBfdGhpcy5tb2RlbHNbX3RoaXMubW9kZWxJbmRleF0gPSBfb2JqZWN0U3ByZWFkKHt9LCBtb3RoZXIpOwogICAgICAgICAgICAgICAgICAgIF90aGlzLm1vZGVsc1tfdGhpcy5tb2RlbEluZGV4XS50cmFpbmluZ3MgPSAwOwogICAgICAgICAgICAgICAgICAgIF90aGlzLm1vZGVsc1tfdGhpcy5tb2RlbEluZGV4XS5oaWdoc2NvcmUgPSB1bmRlZmluZWQ7CiAgICAgICAgICAgICAgICAgICAgbW90aGVyLmNoaWxkcmVuKys7CiAgICAgICAgICAgICAgICAgICAgX3RoaXMubW9kZWxzW190aGlzLm1vZGVsSW5kZXhdLm5hbWUgPSBtb3RoZXIubmFtZSArICIuIiArIG1vdGhlci5jaGlsZHJlbjsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgIF90aGlzLnRyYWluaW5nID0gdHJ1ZTsKICAgICAgICAgICAgICAgIF90aGlzLnRyYWluaW5nU2FtcGxlcyA9IFtdOwoKICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBfdGhpcy5oaWdoc2NvcmVzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICAgICAgICAgIHNhbXBsZXMgPSBbXTsKCiAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBfdGhpcy5oaWdoc2NvcmVzW2ldLnNhbXBsZXMubGVuZ3RoOyBqKyspIHsKICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuaGlnaHNjb3Jlc1tpXS5zYW1wbGVzW2pdLnJld2FyZCA+IDAuNSkgewogICAgICAgICAgICAgICAgICAgICAgLy8gdXNlIG9ubHkgZ29vZCByZXdhcmRzCiAgICAgICAgICAgICAgICAgICAgICBzYW1wbGVzLnB1c2goX3RoaXMuaGlnaHNjb3Jlc1tpXS5zYW1wbGVzW2pdKTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgIChfdGhpcyR0cmFpbmluZ1NhbXBsZXMgPSBfdGhpcy50cmFpbmluZ1NhbXBsZXMpLnB1c2guYXBwbHkoX3RoaXMkdHJhaW5pbmdTYW1wbGVzLCBzYW1wbGVzKTsKICAgICAgICAgICAgICAgIH0gLy8gcmFuZG9taXNlIGFuZCBzbGljZQoKCiAgICAgICAgICAgICAgICBfdGhpcy50cmFpbmluZ1NhbXBsZXMuc29ydChmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgICAgICAgIHJldHVybiAwLjUgLSBNYXRoLnJhbmRvbSgpOwogICAgICAgICAgICAgICAgfSk7CgogICAgICAgICAgICAgICAgX3RoaXMudHJhaW5pbmdTYW1wbGVzID0gX3RoaXMudHJhaW5pbmdTYW1wbGVzLnNsaWNlKDAsIF90aGlzLnRyYWluaW5nU2FtcGxlc01heExlbmd0aCk7CiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygidG90YWwgbnVtYmVyIG9mIHNhbXBsZXM6ICIgKyBfdGhpcy50cmFpbmluZ1NhbXBsZXMubGVuZ3RoKTsKICAgICAgICAgICAgICAgIGZlYXR1cmVWYWx1ZXNUcmFpbmluZyA9IFtdOwogICAgICAgICAgICAgICAgbGFiZWxWYWx1ZXNUcmFpbmluZyA9IFtdOwoKICAgICAgICAgICAgICAgIGZvciAoX2kyID0gMDsgX2kyIDwgX3RoaXMudHJhaW5pbmdTYW1wbGVzLmxlbmd0aDsgX2kyKyspIHsKICAgICAgICAgICAgICAgICAgZmVhdHVyZVZhbHVlVHJhaW5pbmcgPSBfdG9Db25zdW1hYmxlQXJyYXkoX3RoaXMudHJhaW5pbmdTYW1wbGVzW19pMl0uc3RhdGUpOyAvL2ZlYXR1cmVWYWx1ZVRyYWluaW5nLnB1c2goIHRoaXMudHJhaW5pbmdTYW1wbGVzW2ldLnJld2FyZCApOwoKICAgICAgICAgICAgICAgICAgZmVhdHVyZVZhbHVlc1RyYWluaW5nLnB1c2goZmVhdHVyZVZhbHVlVHJhaW5pbmcpOwogICAgICAgICAgICAgICAgICBsYWJlbFZhbHVlc1RyYWluaW5nLnB1c2goX3RoaXMudHJhaW5pbmdTYW1wbGVzW19pMl0uYWN0aW9uKTsKICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICBmZWF0dXJlVGVuc29yVHJhaW5pbmcgPSB0Zi50ZW5zb3IyZChmZWF0dXJlVmFsdWVzVHJhaW5pbmcsIFtmZWF0dXJlVmFsdWVzVHJhaW5pbmcubGVuZ3RoLCBmZWF0dXJlVmFsdWVzVHJhaW5pbmdbMF0ubGVuZ3RoXSk7CiAgICAgICAgICAgICAgICBsYWJlbFRlbnNvclRyYWluaW5nID0gdGYudGVuc29yMmQobGFiZWxWYWx1ZXNUcmFpbmluZywgW2xhYmVsVmFsdWVzVHJhaW5pbmcubGVuZ3RoLCAxXSk7CiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygidHJhaW4gbW9kZWwgLi4uIik7CiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTg7CiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMudHJhaW5Nb2RlbChfdGhpcy5tb2RlbEluZGV4LCBmZWF0dXJlVGVuc29yVHJhaW5pbmcsIGxhYmVsVGVuc29yVHJhaW5pbmcsIE1hdGgubWluKDEwLCBfdGhpcy50cmFpbmluZ1NhbXBsZXNNYXhMZW5ndGggLyBfdGhpcy50cmFpbmluZ1NhbXBsZXMubGVuZ3RoKSAqIDEwKTsKCiAgICAgICAgICAgICAgY2FzZSAxODoKICAgICAgICAgICAgICAgIF90aGlzLnRyYWluaW5nID0gZmFsc2U7CiAgICAgICAgICAgICAgICBfdGhpcy50cmFpbmluZ1Byb2dyZXNzID0gMDsKICAgICAgICAgICAgICAgIF90aGlzLm1vZGVsc1tfdGhpcy5tb2RlbEluZGV4XS50cmFpbmluZ3MgKz0gMTsKCiAgICAgICAgICAgICAgY2FzZSAyMToKICAgICAgICAgICAgICBjYXNlICJlbmQiOgogICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0sIF9jYWxsZWUpOwogICAgICB9KSkoKTsKICAgIH0sCiAgICB0cmFpbk1vZGVsOiBmdW5jdGlvbiB0cmFpbk1vZGVsKG1vZGVsSW5kZXgsIGZlYXR1cmVUZW5zb3JUcmFpbmluZywgbGFiZWxUZW5zb3JUcmFpbmluZywgZXBvY2hzKSB7CiAgICAgIHZhciBfdGhpczIgPSB0aGlzOwoKICAgICAgcmV0dXJuIF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoKSB7CiAgICAgICAgdmFyIHJlZjsKICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0MikgewogICAgICAgICAgd2hpbGUgKDEpIHsKICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7CiAgICAgICAgICAgICAgY2FzZSAwOgogICAgICAgICAgICAgICAgcmVmID0gX3RoaXMyOwogICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoInJldHVybiIsIF90aGlzMi5tb2RlbHNbbW9kZWxJbmRleF0ubW9kZWwuZml0KGZlYXR1cmVUZW5zb3JUcmFpbmluZywgbGFiZWxUZW5zb3JUcmFpbmluZywgewogICAgICAgICAgICAgICAgICBlcG9jaHM6IGVwb2NocywKICAgICAgICAgICAgICAgICAgLy92YWxpZGF0aW9uU3BsaXQ6IDAuMiwKICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzOiB7CiAgICAgICAgICAgICAgICAgICAgb25FcG9jaEVuZDogZnVuY3Rpb24gb25FcG9jaEVuZChlcG9jaCkgewogICAgICAgICAgICAgICAgICAgICAgcmVmLnRyYWluaW5nUHJvZ3Jlc3MgPSBNYXRoLnJvdW5kKGVwb2NoIC8gZXBvY2hzICogMTAwKTsKICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgIG9uVHJhaW5FbmQ6IGZ1bmN0aW9uIG9uVHJhaW5FbmQoKSB7CiAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygiZG9uZSIpOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfSkpOwoKICAgICAgICAgICAgICBjYXNlIDI6CiAgICAgICAgICAgICAgY2FzZSAiZW5kIjoKICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfSwgX2NhbGxlZTIpOwogICAgICB9KSkoKTsKICAgIH0sCiAgICBwcmVkaWN0OiBmdW5jdGlvbiBwcmVkaWN0KG1vZGVsSW5kZXgsIGlucHV0KSB7CiAgICAgIHZhciBfdGhpczMgPSB0aGlzOwoKICAgICAgcmV0dXJuIF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTMoKSB7CiAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzJChfY29udGV4dDMpIHsKICAgICAgICAgIHdoaWxlICgxKSB7CiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQzLnByZXYgPSBfY29udGV4dDMubmV4dCkgewogICAgICAgICAgICAgIGNhc2UgMDoKICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuYWJydXB0KCJyZXR1cm4iLCB0Zi50aWR5KGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgICAgICAgdmFyIGlucHV0VGVuc29yID0gdGYudGVuc29yMmQoW2lucHV0XSwgWzEsIF90aGlzMy52aWV3UmVkdWNlZFNpemUgKiBfdGhpczMudmlld1JlZHVjZWRTaXplXSk7CgogICAgICAgICAgICAgICAgICB2YXIgb3V0cHV0VGVuc29yID0gX3RoaXMzLm1vZGVsc1ttb2RlbEluZGV4XS5tb2RlbC5wcmVkaWN0KGlucHV0VGVuc29yKTsKCiAgICAgICAgICAgICAgICAgIHZhciBvdXRwdXRWYWx1ZSA9IG91dHB1dFRlbnNvci5kYXRhU3luYygpOwogICAgICAgICAgICAgICAgICByZXR1cm4gb3V0cHV0VmFsdWU7CiAgICAgICAgICAgICAgICB9KSk7CgogICAgICAgICAgICAgIGNhc2UgMToKICAgICAgICAgICAgICBjYXNlICJlbmQiOgogICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5zdG9wKCk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9LCBfY2FsbGVlMyk7CiAgICAgIH0pKSgpOwogICAgfSwKICAgIGdldFN0ZWVyaW5nOiBmdW5jdGlvbiBnZXRTdGVlcmluZygpIHsKICAgICAgdmFyIF90aGlzNCA9IHRoaXM7CgogICAgICByZXR1cm4gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlNCgpIHsKICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTQkKF9jb250ZXh0NCkgewogICAgICAgICAgd2hpbGUgKDEpIHsKICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDQucHJldiA9IF9jb250ZXh0NC5uZXh0KSB7CiAgICAgICAgICAgICAgY2FzZSAwOgogICAgICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSAyOwogICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzNC5wcmVkaWN0KF90aGlzNC5tb2RlbEluZGV4LCBfdGhpczQudGVzdGluZ0RhdGFJbnB1dCk7CgogICAgICAgICAgICAgIGNhc2UgMjoKICAgICAgICAgICAgICAgIF90aGlzNC5wcmVkaWN0aW9uID0gX2NvbnRleHQ0LnNlbnQ7CiAgICAgICAgICAgICAgICBfdGhpczQucHJlZGljdGlvbiA9IE1hdGgubWF4KDAsIF90aGlzNC5wcmVkaWN0aW9uKTsKICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYWJydXB0KCJyZXR1cm4iLCBfdGhpczQucHJlZGljdGlvbik7CgogICAgICAgICAgICAgIGNhc2UgNToKICAgICAgICAgICAgICBjYXNlICJlbmQiOgogICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5zdG9wKCk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9LCBfY2FsbGVlNCk7CiAgICAgIH0pKSgpOwogICAgfSwKICAgIHJlZnJlc2hMb29wOiBmdW5jdGlvbiByZWZyZXNoTG9vcCgpIHsKICAgICAgdmFyIF90aGlzNSA9IHRoaXM7CgogICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHsKICAgICAgICB2YXIgbm93ID0gcGVyZm9ybWFuY2Uubm93KCk7CgogICAgICAgIGlmIChfdGhpczUudGljaykgewogICAgICAgICAgX3RoaXM1LnRpY2tUaW1lID0gbm93OwogICAgICAgICAgX3RoaXM1LmZwcyA9IF90aGlzNS5mcHNDb3VudGVyOwogICAgICAgICAgX3RoaXM1LmZwc0NvdW50ZXIgPSAwOwogICAgICAgICAgX3RoaXM1LnRpY2sgPSBmYWxzZTsKICAgICAgICAgIF90aGlzNS5kdXJhdGlvbisrOwogICAgICAgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZSgwKTsKICAgICAgICAgIGRhdGUuc2V0U2Vjb25kcyhfdGhpczUuZHVyYXRpb24pOyAvLyBzcGVjaWZ5IHZhbHVlIGZvciBTRUNPTkRTIGhlcmUKCiAgICAgICAgICBfdGhpczUuZHVyYXRpb25TdHJpbmcgPSBkYXRlLnRvSVNPU3RyaW5nKCkuc3Vic3RyKDExLCA4KTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgX3RoaXM1LmZwc0NvdW50ZXIrKzsKCiAgICAgICAgICBpZiAobm93ID49IF90aGlzNS50aWNrVGltZSArIDEwMDApIHsKICAgICAgICAgICAgX3RoaXM1LnRpY2sgPSB0cnVlOwogICAgICAgICAgfQogICAgICAgIH0KCiAgICAgICAgX3RoaXM1LmVudGVyRnJhbWUoKTsKCiAgICAgICAgX3RoaXM1LnJlZnJlc2hMb29wKCk7CiAgICAgIH0pOwogICAgfSwKICAgIGVudGVyRnJhbWU6IGZ1bmN0aW9uIGVudGVyRnJhbWUoKSB7CiAgICAgIGlmICh0aGlzLndvcmxkTG9hZGVkICYmICF0aGlzLnRyYWluaW5nKSB7CiAgICAgICAgdGhpcy5kcmF3V29ybGQoKTsKICAgICAgICB0aGlzLmdldFZpZXcoKTsKICAgICAgICB0aGlzLm1vdmVDYXIoKTsKICAgICAgfQogICAgfSwKICAgIGRyYXdTdGF0czogZnVuY3Rpb24gZHJhd1N0YXRzKCkgewogICAgICB0aGlzLmN0eFN0YXRzLmNsZWFyUmVjdCgwLCAwLCB0aGlzLmN0eFN0YXRzLmNhbnZhcy53aWR0aCwgdGhpcy5jdHhTdGF0cy5jYW52YXMuaGVpZ2h0KTsgLy90aGlzLmN0eFN0YXRzLmZpbGxSZWN0KDAsIDAsIHRoaXMuY3R4U3RhdHMuY2FudmFzLndpZHRoLCB0aGlzLmN0eFN0YXRzLmNhbnZhcy5oZWlnaHQpOwogICAgICAvL3RoaXMuY3R4U3RhdHMuc3Ryb2tlU3R5bGUgPSAiI2ZmZmZmZiI7CgogICAgICB2YXIgbnVtYmVyT2ZzYW1wbGVzRHJhd24gPSBNYXRoLm1pbig1MTIsIHRoaXMuc2FtcGxlcy5sZW5ndGgpOwoKICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1iZXJPZnNhbXBsZXNEcmF3bjsgaSsrKSB7CiAgICAgICAgLyoKICAgICAgICB0aGlzLmN0eFN0YXRzLm1vdmVUbyggdGhpcy5zYW1wbGVzW2ldLmFjdGlvbiAqIHRoaXMuY3R4U3RhdHMuY2FudmFzLndpZHRoLCB0aGlzLmN0eFN0YXRzLmNhbnZhcy5oZWlnaHQvdGhpcy5zYW1wbGVzLmxlbmd0aCAqIGkgKTsKICAgICAgICB0aGlzLmN0eFN0YXRzLmxpbmVUbyggdGhpcy5zYW1wbGVzW2krMV0uYWN0aW9uICogdGhpcy5jdHhTdGF0cy5jYW52YXMud2lkdGgsIHRoaXMuY3R4U3RhdHMuY2FudmFzLmhlaWdodC90aGlzLnNhbXBsZXMubGVuZ3RoICogKGkrMSkgKTsKICAgICAgICAqLwogICAgICAgIHRoaXMuY3R4U3RhdHMuYmVnaW5QYXRoKCk7CiAgICAgICAgdGhpcy5jdHhTdGF0cy5maWxsU3R5bGUgPSAiI2ZmZmZmZiI7CiAgICAgICAgdGhpcy5jdHhTdGF0cy5hcmModGhpcy5zYW1wbGVzW2ldLmFjdGlvblByZWRpY3RlZCAqIHRoaXMuY3R4U3RhdHMuY2FudmFzLndpZHRoLCB0aGlzLmN0eFN0YXRzLmNhbnZhcy5oZWlnaHQgLyBudW1iZXJPZnNhbXBsZXNEcmF3biAqIGksIDEsIDAsIDIgKiBNYXRoLlBJKTsKICAgICAgICB0aGlzLmN0eFN0YXRzLmZpbGwoKTsKICAgICAgICB0aGlzLmN0eFN0YXRzLmJlZ2luUGF0aCgpOwogICAgICAgIHZhciByZ2IgPSB2b2lkIDA7CgogICAgICAgIGlmICh0aGlzLnNhbXBsZXNbaV0ucmV3YXJkID49IDAuNSkgewogICAgICAgICAgLy9yZ2IgPSAiIzAwZmYwMCI7CiAgICAgICAgICByZ2IgPSAiIzAwIiArIE1hdGgucm91bmQodGhpcy5zYW1wbGVzW2ldLnJld2FyZCAqIDI1NSkudG9TdHJpbmcoMTYpICsgIjAwIjsKICAgICAgICAgIHRoaXMuY3R4U3RhdHMuZmlsbFN0eWxlID0gcmdiOwogICAgICAgICAgdGhpcy5jdHhTdGF0cy5hcmModGhpcy5zYW1wbGVzW2ldLmFjdGlvbiAqIHRoaXMuY3R4U3RhdHMuY2FudmFzLndpZHRoLCB0aGlzLmN0eFN0YXRzLmNhbnZhcy5oZWlnaHQgLyBudW1iZXJPZnNhbXBsZXNEcmF3biAqIGksIDEsIDAsIDIgKiBNYXRoLlBJKTsKICAgICAgICAgIHRoaXMuY3R4U3RhdHMuZmlsbCgpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAvL3JnYiA9ICIjZmYwMDAwIjsKICAgICAgICAgIHJnYiA9ICIjIiArIE1hdGgucm91bmQoKDEgLSB0aGlzLnNhbXBsZXNbaV0ucmV3YXJkKSAqIDI1NSkudG9TdHJpbmcoMTYpICsgIjAwMDAiOwogICAgICAgICAgdGhpcy5jdHhTdGF0cy5maWxsU3R5bGUgPSByZ2I7CiAgICAgICAgICB0aGlzLmN0eFN0YXRzLmFyYyh0aGlzLnNhbXBsZXNbaV0uYWN0aW9uICogdGhpcy5jdHhTdGF0cy5jYW52YXMud2lkdGgsIHRoaXMuY3R4U3RhdHMuY2FudmFzLmhlaWdodCAvIG51bWJlck9mc2FtcGxlc0RyYXduICogaSwgMSwgMCwgMiAqIE1hdGguUEkpOwogICAgICAgICAgdGhpcy5jdHhTdGF0cy5maWxsKCk7CiAgICAgICAgfQogICAgICB9IC8vdGhpcy5jdHhTdGF0cy5zdHJva2UoKTsKCiAgICB9LAogICAgbW92ZUNhcjogZnVuY3Rpb24gbW92ZUNhcigpIHsKICAgICAgdGhpcy50ZXN0aW5nRGF0YUlucHV0ID0gX3RvQ29uc3VtYWJsZUFycmF5KHRoaXMudmlld1BpeGVscyk7IC8vdGhpcy50ZXN0aW5nRGF0YUlucHV0LnB1c2goMS4wKTsKCiAgICAgIHZhciByZWYgPSB0aGlzOwogICAgICB0aGlzLmdldFN0ZWVyaW5nKCkudGhlbihmdW5jdGlvbiAodmFsdWUpIHsKICAgICAgICAvL2NvbnNvbGUubG9nKCJwcmVkaWN0ZWQgc3RlZXJpbmc6ICIrdmFsdWUpOwogICAgICAgIHZhbHVlID0gTWF0aC5taW4odmFsdWUsIDEpOwogICAgICAgIHZhbHVlID0gTWF0aC5tYXgodmFsdWUsIDApOyAvL2NvbnNvbGUubG9nKCJwcmVkaWN0ZWQgc3RlZXJpbmc6ICIrdmFsdWUpOwoKICAgICAgICByZWYuY2FyLnN0ZWVyaW5nUHJlZGljdGVkID0gdmFsdWU7CiAgICAgICAgdmFyIHJhbmRvbWlzYXRpb24gPSAwOwoKICAgICAgICBpZiAocmVmLnNhbXBsZXNbMF0pIHsKICAgICAgICAgIGlmIChyZWYuc2FtcGxlc1swXS5yZXdhcmQgPCAwLjUpIHsKICAgICAgICAgICAgcmFuZG9taXNhdGlvbiA9IE1hdGgubWluKDEsIHJlZi5iYWRSZXdhcmRzIC8gcmVmLnNhbXBsZXMubGVuZ3RoICogcmVmLmJhZFJld2FyZHNJbkFSb3cpOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgcmFuZG9taXNhdGlvbiA9IDAuMDU7CiAgICAgICAgICB9CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHJhbmRvbWlzYXRpb24gPSAxOwogICAgICAgIH0gLy9jb25zb2xlLmxvZygicmFuZG9taXNhdGlvbjogIityYW5kb21pc2F0aW9uKTsKCgogICAgICAgIHZhciByYW5kb20gPSBNYXRoLnJhbmRvbSgpOwogICAgICAgIHZhciByYW5kb21pc2VkVmFsdWUgPSB2YWx1ZSAtIHJhbmRvbWlzYXRpb24gKiAxICsgcmFuZG9tICogcmFuZG9taXNhdGlvbiAqIDI7CiAgICAgICAgcmFuZG9taXNlZFZhbHVlID0gTWF0aC5taW4ocmFuZG9taXNlZFZhbHVlLCAxKTsKICAgICAgICByYW5kb21pc2VkVmFsdWUgPSBNYXRoLm1heChyYW5kb21pc2VkVmFsdWUsIDApOwogICAgICAgIHJlZi5jYXIuc3RlZXJpbmcgPSByYW5kb21pc2VkVmFsdWU7IC8vY29uc29sZS5sb2coIm5ldyBzdGVlcmluZzogIityYW5kb21pc2VkVmFsdWUpOwoKICAgICAgICBpZiAocmVmLmNhci5zdGVlcmluZyA8IDAuNSkgewogICAgICAgICAgLy8gbGVmdAogICAgICAgICAgdmFyIHN0ZWVyaW5nU3RyZW5ndGggPSAoMC41IC0gcmVmLmNhci5zdGVlcmluZykgKiAyOwogICAgICAgICAgcmVmLmNhci5hbmdsZSAtPSByZWYuY2FyLnN0ZWVyaW5nU3BlZWQgKiBzdGVlcmluZ1N0cmVuZ3RoOwogICAgICAgIH0gZWxzZSBpZiAocmVmLmNhci5zdGVlcmluZyA+IDAuNSkgewogICAgICAgICAgLy8gcmlnaHQKICAgICAgICAgIHZhciBfc3RlZXJpbmdTdHJlbmd0aCA9IChyZWYuY2FyLnN0ZWVyaW5nIC0gMC41KSAqIDI7CgogICAgICAgICAgcmVmLmNhci5hbmdsZSArPSByZWYuY2FyLnN0ZWVyaW5nU3BlZWQgKiBfc3RlZXJpbmdTdHJlbmd0aDsKICAgICAgICB9CgogICAgICAgIHJlZi5jYXIueCArPSBNYXRoLnNpbihyZWYuY2FyLmFuZ2xlKSAqIHJlZi5jYXIuc3BlZWQ7CiAgICAgICAgcmVmLmNhci55IC09IE1hdGguY29zKHJlZi5jYXIuYW5nbGUpICogcmVmLmNhci5zcGVlZDsKICAgICAgICByZWYuY2hlY2tDYXJDb2xsaXNpb24oKTsKICAgICAgfSk7CiAgICB9LAogICAgZ2V0VmlldzogZnVuY3Rpb24gZ2V0VmlldygpIHsKICAgICAgLy8gdmlldwogICAgICB0aGlzLmNhci52aWV3WCA9IHRoaXMuY2FyLnggKyBNYXRoLnNpbih0aGlzLmNhci5hbmdsZSkgKiAodGhpcy5jYXIubGVuZ3RoICogMCArIHRoaXMudmlld1NpemUgLyAyKTsKICAgICAgdGhpcy5jYXIudmlld1kgPSB0aGlzLmNhci55IC0gTWF0aC5jb3ModGhpcy5jYXIuYW5nbGUpICogKHRoaXMuY2FyLmxlbmd0aCAqIDAgKyB0aGlzLnZpZXdTaXplIC8gMik7IC8vIGdldCB2aWV3IGltYWdlCgogICAgICB0aGlzLnNuYXBzaG90V2hlcmVWaWV3SXMgPSB0aGlzLmN0eC5nZXRJbWFnZURhdGEodGhpcy5jYXIudmlld1ggLSB0aGlzLmN0eFZpZXdTbmFwc2hvdC5jYW52YXMud2lkdGggLyAyLCB0aGlzLmNhci52aWV3WSAtIHRoaXMuY3R4Vmlld1NuYXBzaG90LmNhbnZhcy5oZWlnaHQgLyAyLCB0aGlzLmN0eFZpZXdTbmFwc2hvdC5jYW52YXMud2lkdGgsIHRoaXMuY3R4Vmlld1NuYXBzaG90LmNhbnZhcy5oZWlnaHQpOyAvLyByZWFkIHBpeGVscwoKICAgICAgdmFyIHZpZXdTbmFwc2hvdFBpeGVscyA9IFtdOwoKICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnNuYXBzaG90V2hlcmVWaWV3SXMuZGF0YS5sZW5ndGg7IGkgKz0gNCkgewogICAgICAgIHZhciByID0gdGhpcy5zbmFwc2hvdFdoZXJlVmlld0lzLmRhdGFbaV07CiAgICAgICAgdmFyIGcgPSB0aGlzLnNuYXBzaG90V2hlcmVWaWV3SXMuZGF0YVtpICsgMV07CiAgICAgICAgdmFyIGIgPSB0aGlzLnNuYXBzaG90V2hlcmVWaWV3SXMuZGF0YVtpICsgMl07CiAgICAgICAgdmlld1NuYXBzaG90UGl4ZWxzLnB1c2goW3IsIGcsIGJdKTsKICAgICAgfSAvLyBkcmF3IHJvdGF0ZWQgaW1hZ2UKCgogICAgICB0aGlzLmN0eFZpZXdTbmFwc2hvdC5zYXZlKCk7CiAgICAgIHRoaXMuY3R4Vmlld1NuYXBzaG90LmNsZWFyUmVjdCgwLCAwLCB0aGlzLmN0eFZpZXdTbmFwc2hvdC5jYW52YXMud2lkdGgsIHRoaXMuY3R4Vmlld1NuYXBzaG90LmNhbnZhcy5oZWlnaHQpOwogICAgICB0aGlzLmN0eFZpZXdTbmFwc2hvdC50cmFuc2xhdGUodGhpcy5jdHhWaWV3U25hcHNob3QuY2FudmFzLndpZHRoIC8gMiwgdGhpcy5jdHhWaWV3U25hcHNob3QuY2FudmFzLmhlaWdodCAvIDIpOwogICAgICB0aGlzLmN0eFZpZXdTbmFwc2hvdC5yb3RhdGUoLXRoaXMuY2FyLmFuZ2xlKTsKICAgICAgdGhpcy5jdHhWaWV3U25hcHNob3QudHJhbnNsYXRlKC10aGlzLmN0eFZpZXdTbmFwc2hvdC5jYW52YXMud2lkdGggLyAyLCAtdGhpcy5jdHhWaWV3U25hcHNob3QuY2FudmFzLmhlaWdodCAvIDIpOwoKICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCB0aGlzLmN0eFZpZXdTbmFwc2hvdC5jYW52YXMuaGVpZ2h0OyB5KyspIHsKICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHRoaXMuY3R4Vmlld1NuYXBzaG90LmNhbnZhcy53aWR0aDsgeCsrKSB7CiAgICAgICAgICB2YXIgcGl4ZWxJbmRleCA9IHkgKiB0aGlzLmN0eFZpZXdTbmFwc2hvdC5jYW52YXMud2lkdGggKyB4OwogICAgICAgICAgdmFyIGNvbG9yID0gdGhpcy5yZ2JUb0hleCh2aWV3U25hcHNob3RQaXhlbHNbcGl4ZWxJbmRleF1bMF0sIHZpZXdTbmFwc2hvdFBpeGVsc1twaXhlbEluZGV4XVsxXSwgdmlld1NuYXBzaG90UGl4ZWxzW3BpeGVsSW5kZXhdWzJdKTsKICAgICAgICAgIHRoaXMuY3R4Vmlld1NuYXBzaG90LmZpbGxTdHlsZSA9IGNvbG9yOwogICAgICAgICAgdGhpcy5jdHhWaWV3U25hcHNob3QuZmlsbFJlY3QoeCwgeSwgMS41LCAxLjUpOwogICAgICAgIH0KICAgICAgfQoKICAgICAgdGhpcy5jdHhWaWV3U25hcHNob3QucmVzdG9yZSgpOyAvLyBnZXQgdmlldyBpbWFnZQoKICAgICAgdGhpcy5pbWdXaGVyZVZpZXdJcyA9IHRoaXMuY3R4Vmlld1NuYXBzaG90LmdldEltYWdlRGF0YSh0aGlzLmN0eFZpZXdTbmFwc2hvdC5jYW52YXMud2lkdGggLyAyIC0gdGhpcy5jdHhWaWV3LmNhbnZhcy53aWR0aCAvIDIsIHRoaXMuY3R4Vmlld1NuYXBzaG90LmNhbnZhcy5oZWlnaHQgLyAyIC0gdGhpcy5jdHhWaWV3LmNhbnZhcy5oZWlnaHQgLyAyLCB0aGlzLmN0eFZpZXcuY2FudmFzLndpZHRoLCB0aGlzLmN0eFZpZXcuY2FudmFzLmhlaWdodCk7CiAgICAgIHRoaXMuY3R4Vmlldy5wdXRJbWFnZURhdGEodGhpcy5pbWdXaGVyZVZpZXdJcywgMCwgMCk7IC8vIHJlYWQgcGl4ZWxzCgogICAgICB2YXIgdmlld1BpeGVscyA9IFtdOwoKICAgICAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgdGhpcy5pbWdXaGVyZVZpZXdJcy5kYXRhLmxlbmd0aDsgX2kzICs9IDQpIHsKICAgICAgICB2YXIgX3IgPSB0aGlzLmltZ1doZXJlVmlld0lzLmRhdGFbX2kzXTsKICAgICAgICB2YXIgX2cgPSB0aGlzLmltZ1doZXJlVmlld0lzLmRhdGFbX2kzICsgMV07CiAgICAgICAgdmFyIF9iID0gdGhpcy5pbWdXaGVyZVZpZXdJcy5kYXRhW19pMyArIDJdOwogICAgICAgIHZpZXdQaXhlbHMucHVzaChbX3IsIF9nLCBfYl0pOwogICAgICB9CgogICAgICB2YXIgdmlld1BpeGVsc1JlZHVjZWQgPSB2aWV3UGl4ZWxzOwoKICAgICAgZm9yICh2YXIgX2k0ID0gMDsgX2k0IDwgdGhpcy52aWV3UmVkdWN0aW9uOyBfaTQrKykgewogICAgICAgIHZpZXdQaXhlbHNSZWR1Y2VkID0gdGhpcy5yZWR1Y2VQaXhlbHModmlld1BpeGVsc1JlZHVjZWQsIE1hdGguc3FydCh2aWV3UGl4ZWxzUmVkdWNlZC5sZW5ndGgpKTsKICAgICAgfSAvLyBkcmF3IHJlZHVjZWQgdmlldwoKCiAgICAgIGZvciAodmFyIF95ID0gMDsgX3kgPCB0aGlzLmN0eFZpZXdSZWR1Y2VkLmNhbnZhcy5oZWlnaHQ7IF95KyspIHsKICAgICAgICBmb3IgKHZhciBfeCA9IDA7IF94IDwgdGhpcy5jdHhWaWV3UmVkdWNlZC5jYW52YXMud2lkdGg7IF94KyspIHsKICAgICAgICAgIHZhciBfcGl4ZWxJbmRleCA9IF95ICogdGhpcy5jdHhWaWV3UmVkdWNlZC5jYW52YXMud2lkdGggKyBfeDsKCiAgICAgICAgICB2YXIgX2NvbG9yID0gdGhpcy5yZ2JUb0hleCh2aWV3UGl4ZWxzUmVkdWNlZFtfcGl4ZWxJbmRleF1bMF0sIHZpZXdQaXhlbHNSZWR1Y2VkW19waXhlbEluZGV4XVsxXSwgdmlld1BpeGVsc1JlZHVjZWRbX3BpeGVsSW5kZXhdWzJdKTsKCiAgICAgICAgICB0aGlzLmN0eFZpZXdSZWR1Y2VkLmZpbGxTdHlsZSA9IF9jb2xvcjsKICAgICAgICAgIHRoaXMuY3R4Vmlld1JlZHVjZWQuZmlsbFJlY3QoX3gsIF95LCAxLjUsIDEuNSk7CiAgICAgICAgfQogICAgICB9CgogICAgICB2YXIgcHJldmlvdXNUb3RhbEJyaWdodG5lc3M7IC8vIGNyZWF0ZSBzYW1wbGUKCiAgICAgIGlmICh0aGlzLnZpZXdQaXhlbHMpIHsKICAgICAgICAvLyBoYXMgcHJldmlvdXMgc3RhdGUKICAgICAgICB0aGlzLnNhbXBsZXMudW5zaGlmdCh7CiAgICAgICAgICBzdGF0ZTogdGhpcy52aWV3UGl4ZWxzLAogICAgICAgICAgYWN0aW9uOiB0aGlzLmNhci5zdGVlcmluZywKICAgICAgICAgIGFjdGlvblByZWRpY3RlZDogdGhpcy5jYXIuc3RlZXJpbmdQcmVkaWN0ZWQKICAgICAgICB9KTsgLy90aGlzLnNhbXBsZXMgPSB0aGlzLnNhbXBsZXMuc2xpY2UoMCx0aGlzLnNhbXBsZXNNYXhMZW5ndGgpOwoKICAgICAgICBwcmV2aW91c1RvdGFsQnJpZ2h0bmVzcyA9IHRoaXMudG90YWxCcmlnaHRuZXNzOwogICAgICB9IC8vIHNhdmUgbmV3IHZpZXcgcGl4ZWxzCgoKICAgICAgdGhpcy52aWV3UGl4ZWxzID0gW107CiAgICAgIHRoaXMudG90YWxCcmlnaHRuZXNzID0gMDsKCiAgICAgIGZvciAodmFyIF9pNSA9IDA7IF9pNSA8IHZpZXdQaXhlbHNSZWR1Y2VkLmxlbmd0aDsgX2k1KyspIHsKICAgICAgICB2YXIgYnJpZ2h0bmVzcyA9ICh2aWV3UGl4ZWxzUmVkdWNlZFtfaTVdWzBdICsgdmlld1BpeGVsc1JlZHVjZWRbX2k1XVsxXSArIHZpZXdQaXhlbHNSZWR1Y2VkW19pNV1bMl0pIC8gNzY1OwogICAgICAgIHRoaXMudmlld1BpeGVscy5wdXNoKGJyaWdodG5lc3MpOwogICAgICAgIHRoaXMudG90YWxCcmlnaHRuZXNzICs9IGJyaWdodG5lc3M7CiAgICAgIH0KCiAgICAgIHRoaXMudG90YWxCcmlnaHRuZXNzID0gdGhpcy50b3RhbEJyaWdodG5lc3MgLyB0aGlzLnZpZXdQaXhlbHMubGVuZ3RoOwoKICAgICAgaWYgKHRoaXMuc2FtcGxlcy5sZW5ndGgpIHsKICAgICAgICB2YXIgYnJpZ2h0bmVzc0NoYW5nZSA9IHRoaXMudG90YWxCcmlnaHRuZXNzIC0gcHJldmlvdXNUb3RhbEJyaWdodG5lc3M7CiAgICAgICAgY29uc29sZS5sb2coIi0tLSIpOyAvL2NvbnNvbGUubG9nKCAidG90YWxCcmlnaHRuZXNzOiAiKyB0aGlzLnRvdGFsQnJpZ2h0bmVzcyApOwogICAgICAgIC8vY29uc29sZS5sb2coICJwcmV2aW91c1RvdGFsQnJpZ2h0bmVzczogIisgcHJldmlvdXNUb3RhbEJyaWdodG5lc3MgKTsKICAgICAgICAvL2NvbnNvbGUubG9nKCAiYnJpZ2h0bmVzc0NoYW5nZTogIisgYnJpZ2h0bmVzc0NoYW5nZSApOwoKICAgICAgICB2YXIgcmV3YXJkOwoKICAgICAgICBpZiAoYnJpZ2h0bmVzc0NoYW5nZSA+PSAwKSB7CiAgICAgICAgICAvLyBiZXR0ZXIKICAgICAgICAgIGlmICh0aGlzLnRvdGFsQnJpZ2h0bmVzcyA+IDAuNSkgewogICAgICAgICAgICAvLyBub3Qgc28gYmFkIHNpdHVhdGlvbgogICAgICAgICAgICByZXdhcmQgPSAxOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgLy8gYmFkIHNpdHVhdGlvbgogICAgICAgICAgICByZXdhcmQgPSAwLjc1ICsgTWF0aC5taW4oMC4yNSwgYnJpZ2h0bmVzc0NoYW5nZSAqIDEwICogdGhpcy50b3RhbEJyaWdodG5lc3MpOwogICAgICAgICAgfSAvL3Jld2FyZCA9IDE7CiAgICAgICAgICAvL2NvbnNvbGUubG9nKHJld2FyZCsiOiBiZXR0ZXIiKTsKCiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIC8vIHdvcnNlCiAgICAgICAgICBpZiAodGhpcy50b3RhbEJyaWdodG5lc3MgPCAwLjUpIHsKICAgICAgICAgICAgLy8gYmFkIHNpdHVhdGlvbgogICAgICAgICAgICByZXdhcmQgPSAwOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgLy8gYmFkIHNpdHVhdGlvbgogICAgICAgICAgICByZXdhcmQgPSBNYXRoLm1pbigwLjI1LCBNYXRoLmFicyhicmlnaHRuZXNzQ2hhbmdlKSAqIDEwICogdGhpcy50b3RhbEJyaWdodG5lc3MpOwogICAgICAgICAgfQoKICAgICAgICAgIHJld2FyZCA9IDA7IC8vY29uc29sZS5sb2cocmV3YXJkKyI6IHdvcnNlIik7CiAgICAgICAgfQoKICAgICAgICB0aGlzLnNhbXBsZXNbMF0ucmV3YXJkID0gcmV3YXJkOyAvLyBjYWxjdWxhdGUgdG90YWwgYWNjdWFyY3kKCiAgICAgICAgaWYgKHJld2FyZCA8IDAuNSkgewogICAgICAgICAgdGhpcy5iYWRSZXdhcmRzKys7CiAgICAgICAgICB0aGlzLmJhZFJld2FyZHNJbkFSb3crKzsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgdGhpcy5iYWRSZXdhcmRzSW5BUm93ID0gMDsKICAgICAgICB9IC8vIHRyaW0gc2FtcGxlczoKCgogICAgICAgIGlmICh0aGlzLnNhbXBsZXMubGVuZ3RoID09PSB0aGlzLnNhbXBsZXNNYXhMZW5ndGgpIHsKICAgICAgICAgIC8vY29uc29sZS5sb2coIm1heCBsZW5ndGggcmVhY2hlZDogIit0aGlzLnNhbXBsZXMubGVuZ3RoKTsKICAgICAgICAgIGlmICh0aGlzLnNhbXBsZXNbdGhpcy5zYW1wbGVzLmxlbmd0aCAtIDFdLnJld2FyZCA8IDAuNSkgewogICAgICAgICAgICAvL2NvbnNvbGUubG9nKCJsYXN0IGlzIGJhZFJld2FyZCIpOwogICAgICAgICAgICB0aGlzLmJhZFJld2FyZHMtLTsKICAgICAgICAgIH0gLy9jb25zb2xlLmxvZygicmVtb3ZlIik7CgoKICAgICAgICAgIHRoaXMuc2FtcGxlcyA9IHRoaXMuc2FtcGxlcy5zbGljZSgwLCB0aGlzLnNhbXBsZXNNYXhMZW5ndGggLSAxKTsgLy9jb25zb2xlLmxvZygibmV3IGxlbmd0aDogIiArdGhpcy5zYW1wbGVzLmxlbmd0aCk7CiAgICAgICAgfQoKICAgICAgICBjb25zb2xlLmxvZygiZ29vZCBzYW1wbGVzOiAiICsgKHRoaXMuc2FtcGxlcy5sZW5ndGggLSB0aGlzLmJhZFJld2FyZHMpICsgIiBvZiAiICsgdGhpcy5zYW1wbGVzLmxlbmd0aCk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgLy8gZmlyc3QgY3ljbGUKICAgICAgICB0aGlzLmJhZFJld2FyZHMgPSAwOwogICAgICAgIHRoaXMuYmFkUmV3YXJkc0luQVJvdyA9IDA7CiAgICAgIH0KICAgIH0sCiAgICBjaGVja0NhckNvbGxpc2lvbjogZnVuY3Rpb24gY2hlY2tDYXJDb2xsaXNpb24oKSB7CiAgICAgIC8vIGdldCBjYXIgaW1hZ2UKICAgICAgdGhpcy5zbmFwc2hvdFdoZXJlQ2FySXMgPSB0aGlzLmN0eC5nZXRJbWFnZURhdGEodGhpcy5jYXIueCAtIHRoaXMuY3R4Q2FyU25hcHNob3QuY2FudmFzLndpZHRoIC8gMiwgdGhpcy5jYXIueSAtIHRoaXMuY3R4Q2FyU25hcHNob3QuY2FudmFzLmhlaWdodCAvIDIsIHRoaXMuY3R4Q2FyU25hcHNob3QuY2FudmFzLndpZHRoLCB0aGlzLmN0eENhclNuYXBzaG90LmNhbnZhcy5oZWlnaHQpOyAvLyByZWFkIHBpeGVscwoKICAgICAgdmFyIGNhclNuYXBzaG90UGl4ZWxzID0gW107CgogICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc25hcHNob3RXaGVyZUNhcklzLmRhdGEubGVuZ3RoOyBpICs9IDQpIHsKICAgICAgICB2YXIgciA9IHRoaXMuc25hcHNob3RXaGVyZUNhcklzLmRhdGFbaV07CiAgICAgICAgdmFyIGcgPSB0aGlzLnNuYXBzaG90V2hlcmVDYXJJcy5kYXRhW2kgKyAxXTsKICAgICAgICB2YXIgYiA9IHRoaXMuc25hcHNob3RXaGVyZUNhcklzLmRhdGFbaSArIDJdOwogICAgICAgIGNhclNuYXBzaG90UGl4ZWxzLnB1c2goW3IsIGcsIGJdKTsKICAgICAgfSAvLyBkcmF3IHJvdGF0ZWQgaW1hZ2UKCgogICAgICB0aGlzLmN0eENhclNuYXBzaG90LnNhdmUoKTsKICAgICAgdGhpcy5jdHhDYXJTbmFwc2hvdC5jbGVhclJlY3QoMCwgMCwgdGhpcy5jdHhDYXJTbmFwc2hvdC5jYW52YXMud2lkdGgsIHRoaXMuY3R4Q2FyU25hcHNob3QuY2FudmFzLmhlaWdodCk7CiAgICAgIHRoaXMuY3R4Q2FyU25hcHNob3QudHJhbnNsYXRlKHRoaXMuY3R4Q2FyU25hcHNob3QuY2FudmFzLndpZHRoIC8gMiwgdGhpcy5jdHhDYXJTbmFwc2hvdC5jYW52YXMuaGVpZ2h0IC8gMik7CiAgICAgIHRoaXMuY3R4Q2FyU25hcHNob3Qucm90YXRlKC10aGlzLmNhci5hbmdsZSk7CiAgICAgIHRoaXMuY3R4Q2FyU25hcHNob3QudHJhbnNsYXRlKC10aGlzLmN0eENhclNuYXBzaG90LmNhbnZhcy53aWR0aCAvIDIsIC10aGlzLmN0eENhclNuYXBzaG90LmNhbnZhcy5oZWlnaHQgLyAyKTsKCiAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgdGhpcy5jdHhDYXJTbmFwc2hvdC5jYW52YXMuaGVpZ2h0OyB5KyspIHsKICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHRoaXMuY3R4Q2FyU25hcHNob3QuY2FudmFzLndpZHRoOyB4KyspIHsKICAgICAgICAgIHZhciBwaXhlbEluZGV4ID0geSAqIHRoaXMuY3R4Q2FyU25hcHNob3QuY2FudmFzLndpZHRoICsgeDsKICAgICAgICAgIHZhciBjb2xvciA9IHRoaXMucmdiVG9IZXgoY2FyU25hcHNob3RQaXhlbHNbcGl4ZWxJbmRleF1bMF0sIGNhclNuYXBzaG90UGl4ZWxzW3BpeGVsSW5kZXhdWzFdLCBjYXJTbmFwc2hvdFBpeGVsc1twaXhlbEluZGV4XVsyXSk7CiAgICAgICAgICB0aGlzLmN0eENhclNuYXBzaG90LmZpbGxTdHlsZSA9IGNvbG9yOwogICAgICAgICAgdGhpcy5jdHhDYXJTbmFwc2hvdC5maWxsUmVjdCh4LCB5LCAxLjUsIDEuNSk7CiAgICAgICAgfQogICAgICB9CgogICAgICB0aGlzLmN0eENhclNuYXBzaG90LnJlc3RvcmUoKTsgLy8gZ2V0IGNhciBpbWFnZQoKICAgICAgdGhpcy5pbWdXaGVyZUNhcklzID0gdGhpcy5jdHhDYXJTbmFwc2hvdC5nZXRJbWFnZURhdGEodGhpcy5jdHhDYXJTbmFwc2hvdC5jYW52YXMud2lkdGggLyAyIC0gdGhpcy5jdHhDYXIuY2FudmFzLndpZHRoIC8gMiwgdGhpcy5jdHhDYXJTbmFwc2hvdC5jYW52YXMuaGVpZ2h0IC8gMiAtIHRoaXMuY3R4Q2FyLmNhbnZhcy5oZWlnaHQgLyAyLCB0aGlzLmN0eENhci5jYW52YXMud2lkdGgsIHRoaXMuY3R4Q2FyLmNhbnZhcy5oZWlnaHQpOwogICAgICB0aGlzLmN0eENhci5wdXRJbWFnZURhdGEodGhpcy5pbWdXaGVyZUNhcklzLCAwLCAwKTsKICAgICAgdGhpcy5kcmF3Q2FyQW5kVmlld1NxdWFyZSgpOyAvLyByZWFkIHBpeGVscwoKICAgICAgdmFyIHRvdGFsUiA9IDA7CiAgICAgIHZhciB0b3RhbEcgPSAwOwogICAgICB2YXIgdG90YWxCID0gMDsKCiAgICAgIGZvciAodmFyIF9pNiA9IDA7IF9pNiA8IHRoaXMuaW1nV2hlcmVDYXJJcy5kYXRhLmxlbmd0aDsgX2k2ICs9IDQpIHsKICAgICAgICB0b3RhbFIgKz0gdGhpcy5pbWdXaGVyZUNhcklzLmRhdGFbX2k2XTsKICAgICAgICB0b3RhbEcgKz0gdGhpcy5pbWdXaGVyZUNhcklzLmRhdGFbX2k2ICsgMV07CiAgICAgICAgdG90YWxCICs9IHRoaXMuaW1nV2hlcmVDYXJJcy5kYXRhW19pNiArIDJdOwogICAgICB9CgogICAgICB0b3RhbFIgPSBNYXRoLnJvdW5kKHRvdGFsUiAvICh0aGlzLmltZ1doZXJlQ2FySXMuZGF0YS5sZW5ndGggLyA0KSk7CiAgICAgIHRvdGFsRyA9IE1hdGgucm91bmQodG90YWxHIC8gKHRoaXMuaW1nV2hlcmVDYXJJcy5kYXRhLmxlbmd0aCAvIDQpKTsKICAgICAgdG90YWxCID0gTWF0aC5yb3VuZCh0b3RhbEIgLyAodGhpcy5pbWdXaGVyZUNhcklzLmRhdGEubGVuZ3RoIC8gNCkpOwoKICAgICAgaWYgKHRvdGFsUiArIHRvdGFsRyArIHRvdGFsQiA8IDc2MCkgewogICAgICAgIGNvbnNvbGUubG9nKCJjb2xsaXNpb24hIik7CiAgICAgICAgdGhpcy52aWV3UGl4ZWxzID0gbnVsbDsKICAgICAgICB0aGlzLmNhci5zdGVlcmluZyA9IHVuZGVmaW5lZDsKICAgICAgICB0aGlzLnJlc2V0Q2FyKCk7CgogICAgICAgIGlmICh0aGlzLmhpZ2hzY29yZXMubGVuZ3RoIDwgdGhpcy5oaWdoc2NvcmVzTWF4TGVuZ3RoIHx8IHRoaXMuc2NvcmUgPiB0aGlzLmhpZ2hzY29yZXNbdGhpcy5oaWdoc2NvcmVzTWF4TGVuZ3RoIC0gMV0uc2NvcmUpIHsKICAgICAgICAgIGNvbnNvbGUubG9nKCJuZXcgaGlnaHNjb3JlIik7CiAgICAgICAgICB0aGlzLmhpZ2hzY29yZXMucHVzaCh7CiAgICAgICAgICAgIHNjb3JlOiB0aGlzLnNjb3JlLAogICAgICAgICAgICBzYW1wbGVzOiBfdG9Db25zdW1hYmxlQXJyYXkodGhpcy5zYW1wbGVzKSwKICAgICAgICAgICAgbW9kZWxJbmRleDogdGhpcy5tb2RlbEluZGV4CiAgICAgICAgICB9KTsKICAgICAgICAgIHRoaXMuaGlnaHNjb3Jlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7CiAgICAgICAgICAgIHJldHVybiBiLnNjb3JlIC0gYS5zY29yZTsKICAgICAgICAgIH0pOwogICAgICAgICAgdGhpcy5oaWdoc2NvcmVzID0gdGhpcy5oaWdoc2NvcmVzLnNsaWNlKDAsIHRoaXMuaGlnaHNjb3Jlc01heExlbmd0aCk7CiAgICAgICAgfQoKICAgICAgICBjb25zb2xlLmxvZygidHJhaW4iKTsKICAgICAgICB0aGlzLnRyYWluKCk7CiAgICAgICAgdGhpcy5kcmF3U3RhdHMoKTsKICAgICAgICB0aGlzLnNhbXBsZXMgPSBbXTsKICAgICAgICB0aGlzLmxhc3RTY29yZSA9IHRoaXMuc2NvcmU7CiAgICAgICAgdGhpcy5zY29yZSA9IDA7IC8vdGhpcy5yZWZyZXNoTG9vcCA9IG51bGw7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgdGhpcy5zY29yZSsrOwogICAgICAgIHRoaXMuZHJhd1N0YXRzKCk7CiAgICAgIH0KICAgIH0sCiAgICBkcmF3Q2FyQW5kVmlld1NxdWFyZTogZnVuY3Rpb24gZHJhd0NhckFuZFZpZXdTcXVhcmUoKSB7CiAgICAgIC8vIGRyYXcgY2FyCiAgICAgIHRoaXMuY3R4LnNhdmUoKTsKICAgICAgdGhpcy5jdHgudHJhbnNsYXRlKHRoaXMuY2FyLngsIHRoaXMuY2FyLnkpOwogICAgICB0aGlzLmN0eC5yb3RhdGUodGhpcy5jYXIuYW5nbGUpOwogICAgICB0aGlzLmN0eC50cmFuc2xhdGUoLXRoaXMuY2FyLngsIC10aGlzLmNhci55KTsKICAgICAgdGhpcy5jdHguZmlsbFJlY3QodGhpcy5jYXIueCAtIHRoaXMuY2FyLndpZHRoIC8gMiwgdGhpcy5jYXIueSAtIHRoaXMuY2FyLmxlbmd0aCAvIDIsIHRoaXMuY2FyLndpZHRoLCB0aGlzLmNhci5sZW5ndGgpOwogICAgICB0aGlzLmN0eC5yZXN0b3JlKCk7IC8vIGRyYXcgdmlldyByZWN0CgogICAgICB0aGlzLmN0eC5zYXZlKCk7CiAgICAgIHRoaXMuY3R4LnRyYW5zbGF0ZSh0aGlzLmNhci52aWV3WCwgdGhpcy5jYXIudmlld1kpOwogICAgICB0aGlzLmN0eC5yb3RhdGUodGhpcy5jYXIuYW5nbGUpOwogICAgICB0aGlzLmN0eC50cmFuc2xhdGUoLXRoaXMuY2FyLnZpZXdYLCAtdGhpcy5jYXIudmlld1kpOwogICAgICB0aGlzLmN0eC5zdHJva2VTdHlsZSA9ICIjZmYwMDAwIjsKICAgICAgdGhpcy5jdHguYmVnaW5QYXRoKCk7CiAgICAgIHRoaXMuY3R4LnJlY3QodGhpcy5jYXIudmlld1ggLSB0aGlzLmN0eFZpZXcuY2FudmFzLndpZHRoIC8gMiwgdGhpcy5jYXIudmlld1kgLSB0aGlzLmN0eFZpZXcuY2FudmFzLmhlaWdodCAvIDIsIHRoaXMuY3R4Vmlldy5jYW52YXMud2lkdGgsIHRoaXMuY3R4Vmlldy5jYW52YXMuaGVpZ2h0KTsKICAgICAgdGhpcy5jdHguc3Ryb2tlKCk7CiAgICAgIHRoaXMuY3R4LnJlc3RvcmUoKTsKICAgIH0sCiAgICBjb21wb25lbnRUb0hleDogZnVuY3Rpb24gY29tcG9uZW50VG9IZXgoYykgewogICAgICB2YXIgaGV4ID0gYy50b1N0cmluZygxNik7CiAgICAgIHJldHVybiBoZXgubGVuZ3RoID09IDEgPyAiMCIgKyBoZXggOiBoZXg7CiAgICB9LAogICAgcmdiVG9IZXg6IGZ1bmN0aW9uIHJnYlRvSGV4KHIsIGcsIGIpIHsKICAgICAgcmV0dXJuICIjIiArIHRoaXMuY29tcG9uZW50VG9IZXgocikgKyB0aGlzLmNvbXBvbmVudFRvSGV4KGcpICsgdGhpcy5jb21wb25lbnRUb0hleChiKTsKICAgIH0sCiAgICByZWR1Y2VQaXhlbHM6IGZ1bmN0aW9uIHJlZHVjZVBpeGVscyhwaXhlbHMsIHNpemUpIHsKICAgICAgLy8gcmVkdWNlIHJlc29sdXRpb24KICAgICAgdmFyIHBpeGVsc1JlZHVjZWQgPSBbXTsKCiAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgc2l6ZTsgeSArPSAyKSB7CiAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCBzaXplOyB4ICs9IDIpIHsKICAgICAgICAgIHZhciBwaXhlbEluZGV4ZXMgPSBbeSAqIHNpemUgKyB4LCB5ICogc2l6ZSArIHggKyAxLCAoeSArIDEpICogc2l6ZSArIHgsICh5ICsgMSkgKiBzaXplICsgeCArIDFdOwogICAgICAgICAgdmFyIHRvdGFsUiA9IDA7CiAgICAgICAgICB2YXIgdG90YWxHID0gMDsKICAgICAgICAgIHZhciB0b3RhbEIgPSAwOwoKICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGl4ZWxJbmRleGVzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICAgIHRvdGFsUiArPSBwaXhlbHNbcGl4ZWxJbmRleGVzW2ldXVswXTsKICAgICAgICAgICAgdG90YWxHICs9IHBpeGVsc1twaXhlbEluZGV4ZXNbaV1dWzFdOwogICAgICAgICAgICB0b3RhbEIgKz0gcGl4ZWxzW3BpeGVsSW5kZXhlc1tpXV1bMl07CiAgICAgICAgICB9CgogICAgICAgICAgdG90YWxSID0gTWF0aC5yb3VuZCh0b3RhbFIgLyBwaXhlbEluZGV4ZXMubGVuZ3RoKTsKICAgICAgICAgIHRvdGFsRyA9IE1hdGgucm91bmQodG90YWxHIC8gcGl4ZWxJbmRleGVzLmxlbmd0aCk7CiAgICAgICAgICB0b3RhbEIgPSBNYXRoLnJvdW5kKHRvdGFsQiAvIHBpeGVsSW5kZXhlcy5sZW5ndGgpOwogICAgICAgICAgcGl4ZWxzUmVkdWNlZC5wdXNoKFt0b3RhbFIsIHRvdGFsRywgdG90YWxCXSk7CiAgICAgICAgfQogICAgICB9CgogICAgICByZXR1cm4gcGl4ZWxzUmVkdWNlZDsKICAgIH0sCiAgICBkcmF3V29ybGQ6IGZ1bmN0aW9uIGRyYXdXb3JsZCgpIHsKICAgICAgdGhpcy5jdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMuY3R4LmNhbnZhcy53aWR0aCwgdGhpcy5jdHguY2FudmFzLmhlaWdodCk7CiAgICAgIHRoaXMuY3R4LmRyYXdJbWFnZSh0aGlzLmltZ1dvcmxkLCAwLCAwLCB0aGlzLmN0eC5jYW52YXMud2lkdGgsIHRoaXMuY3R4LmNhbnZhcy5oZWlnaHQpOwogICAgfSwKICAgIHJlc2V0Q2FyOiBmdW5jdGlvbiByZXNldENhcigpIHsKICAgICAgY29uc29sZS5sb2coInJlc2V0IGNhciIpOwogICAgICB0aGlzLmNhci54ID0gdGhpcy53b3JsZFdpZHRoIC8gMiAqIDAuMjU7CiAgICAgIHRoaXMuY2FyLnkgPSB0aGlzLndvcmxkSGVpZ2h0IC8gMiAqIDEuNTsKICAgICAgdGhpcy5jYXIuYW5nbGUgPSAwOwogICAgfQogICAgLyoKICAgIGtleURvd24oZSkgewogICAgICBpZiggZS5jb2RlID09PSAiQXJyb3dMZWZ0IiApIHsKICAgICAgICB0aGlzLmNhci5zdGVlcmluZyA9IDA7CiAgICAgIH0KICAgICAgZWxzZSBpZiggZS5jb2RlID09PSAiQXJyb3dSaWdodCIgKSB7CiAgICAgICAgdGhpcy5jYXIuc3RlZXJpbmcgPSAxOwogICAgICB9CiAgICB9LAogICAga2V5VXAoZSkgewogICAgICBpZiggZS5jb2RlID09PSAiQXJyb3dMZWZ0IiApIHsKICAgICAgICB0aGlzLmNhci5zdGVlcmluZyA9IHVuZGVmaW5lZDsKICAgICAgfQogICAgICBlbHNlIGlmKCBlLmNvZGUgPT09ICJBcnJvd1JpZ2h0IiApIHsKICAgICAgICB0aGlzLmNhci5zdGVlcmluZyA9IHVuZGVmaW5lZDsKICAgICAgfQogICAgfQogICAgKi8KCiAgfQp9Ow=="},{"version":3,"mappings":"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CA;AACA;AACA,yGAHA,CAIA;;AACA,+OALA,CAMA;;AACA;;AACA;AACA;AACA;AACA;AACAC;AACA,OAbA,CAcA;;;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,qCA5BA,CA6BA;;AACA;AACA,2DA/BA,CAgCA;;AACA;;AACA;AACA;AACA;AACA;AACArE;AACA;;AACA;;AACA;AACAsE;AACA,OA3CA,CA4CA;;;AACA;AACA;AACA;;AACA;;AACA;AACA;AACA;AACA;;AAEA,kCAtDA,CAuDA;;AACA;AACA;AACA;AACAC,gCADA;AAEAC,mCAFA;AAGAC;AAHA,WAFA,CAOA;;AACAC;AACA,OAjEA,CAmEA;;;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AACA;;AAEA;AACA;AACAhD,2BAFA,CAGA;AACA;AACA;;AACA;;AACA;AACA;AACA;AACA;AACAiD;AACA,WAHA,MAIA;AACA;AACAA;AACA,WATA,CAUA;AACA;;AACA,SAZA,MAaA;AACA;AACA;AACA;AACAA;AACA,WAHA,MAIA;AACA;AACAA;AACA;;AACAA,qBAVA,CAWA;AACA;;AACA,wCAjCA,CAoCA;;AACA;AACA;AACA;AACA,SAHA,MAIA;AACA;AACA,SA3CA,CA8CA;;;AACA;AACA;AACA;AACA;AACA;AACA,WALA,CAMA;;;AACA,0EAPA,CAQA;AACA;;AACAjD;AAEA,OA3DA,MA4DA;AACA;AACA;AACA;AACA;AAEA,KAvbA;AAwbAkD,qBAxbA,+BAwbA;AACA;AACA,kOAFA,CAGA;;AACA;;AACA;AACA;AACA;AACA;AACAC;AACA,OAVA,CAWA;;;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,oCAzBA,CA0BA;;AACA;AACA;AAIA,kCAhCA,CAmCA;;AACA;AACA;AACA;;AACA;AACAC;AACAC;AACAC;AACA;;AACAF;AACAC;AACAC;;AACA;AACAtD;AAEA;AACA;AACA;;AAEA;AACAA;AAEA;AACAlB,6BADA;AAEAN,qDAFA;AAGAe;AAHA;AAKA;AAAA;AAAA;AACA;AACA;;AACAS;AACA;AAEA;AAEA;AACA;AACA,uBAzBA,CA2BA;AACA,OA5BA,MA6BA;AACA;AACA;AACA;AACA,KAxgBA;AAygBAuD,wBAzgBA,kCAygBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAPA,CASA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KA5hBA;AA6hBAC,kBA7hBA,0BA6hBAC,CA7hBA,EA6hBA;AACA;AACA;AACA,KAhiBA;AAiiBAC,YAjiBA,oBAiiBAC,CAjiBA,EAiiBAC,CAjiBA,EAiiBAC,CAjiBA,EAiiBA;AACA;AACA,KAniBA;AAoiBAC,gBApiBA,wBAoiBAC,MApiBA,EAoiBAC,IApiBA,EAoiBA;AACA;AACA;;AACA;AACA;AACA,8BACAjG,YADA,EAEAA,gBAFA,EAGA,kBAHA,EAIA,sBAJA;AAOA;AACA;AACA;;AACA;AACAqF;AACAC;AACAC;AACA;;AACAF;AACAC;AACAC;AACAW;AACA;AACA;;AACA;AACA,KA/jBA;AAgkBAC,aAhkBA,uBAgkBA;AACA;AACA;AACA,KAnkBA;AAokBAC,YApkBA,sBAokBA;AACAnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AA3lBA;AA1FA","names":["name","data","ctx","worldWidth","worldHeight","imgWorld","worldLoaded","fps","fpsCounter","tick","tickTime","duration","durationString","car","width","length","x","y","speed","steeringSpeed","angle","viewSize","viewReduction","viewReducedSize","viewPixels","steering","samples","samplesMaxLength","trainingSamples","trainingSamplesMaxLength","badRewards","badRewardsInARow","score","lastScore","highscores","highscoresMaxLength","highscoresMaxShown","training","trainingProgress","models","numberOfModels","modelIndex","computed","reducedViewSize","reducedSize","highscoresShown","mounted","app","methods","createModel","console","layers","units","activation","trainings","highscore","children","inputShape","loss","optimizer","metrics","train","highscoreOfModel","random","Math","highscoreIndex","mother","featureValuesTraining","labelValuesTraining","featureValueTraining","featureTensorTraining","tf","labelTensorTraining","trainModel","epochs","ref","callbacks","onEpochEnd","onTrainEnd","predict","input","getSteering","refreshLoop","window","date","enterFrame","drawStats","rgb","moveCar","value","randomisation","randomisedValue","getView","viewSnapshotPixels","viewPixelsReduced","state","action","actionPredicted","previousTotalBrightness","reward","checkCarCollision","carSnapshotPixels","totalR","totalG","totalB","drawCarAndViewSquare","componentToHex","c","rgbToHex","r","g","b","reducePixels","pixels","size","pixelsReduced","drawWorld","resetCar"],"sourceRoot":"src","sources":["App.vue"],"sourcesContent":["<template>\n  <div id=\"app\">\n    <div class=\"world\">\n      <canvas class=\"world-canvas\" ref=\"canvas\" :width=\"worldWidth\" :height=\"worldHeight\"></canvas>\n      <div class=\"training\" v-if=\"training\"><span>TRAINING<br>{{trainingProgress}}% ({{trainingSamples.length}})</span></div>\n    </div>\n    <canvas class=\"car-snapshot-canvas\" ref=\"carSnapshotCanvas\" :width=\"car.length*1.5\" :height=\"car.length*1.5\"></canvas>\n    <canvas class=\"view-snapshot-canvas\" ref=\"viewSnapshotCanvas\" :width=\"viewSize*1.5\" :height=\"viewSize*1.5\"></canvas>\n    <canvas class=\"car-canvas\" ref=\"carCanvas\" :width=\"car.width\" :height=\"car.length\"></canvas>\n    <canvas class=\"view-canvas\" ref=\"viewCanvas\" :width=\"viewSize\" :height=\"viewSize\"></canvas>\n    <canvas class=\"view-canvas-reduced\" ref=\"viewCanvasReduced\" :width=\"reducedViewSize\" :height=\"reducedViewSize\"></canvas>\n    <span class=\"fps\">{{ fps }} fps</span>\n    <div class=\"highscores\">\n      <div class=\"duration\">\n        <label>Total Duration</label>\n        {{durationString}}\n      </div>\n      <label>Highscores ({{highscores.length}})</label>\n      <ul>\n        <li v-for=\"(highscore,index) in highscoresShown\" :key=\"index\"><b>{{models[highscore.modelIndex].name}} - </b> {{highscore.score}}</li>\n        <!-- <li v-if=\"highscores.length\">last: {{highscores[highscores.length-1].score}}</li> -->\n      </ul>\n    </div>\n    <div class=\"score\">\n      <div class=\"current\">\n        <label>Current Score</label>\n        {{score}}\n      </div>\n      <div class=\"last\">\n        <label>Last Score</label>\n        {{lastScore}}\n      </div>\n    </div>\n    <div class=\"stats\">\n      <canvas class=\"stats-canvas\" ref=\"statsCanvas\" :width=\"40\" :height=\"500\"></canvas>\n    </div>\n    <div class=\"models\">\n      <label>Drivers</label>\n      <ul>\n        <li v-for=\"(model,index) in models\" :key=\"index\" :class=\"{'active':index === modelIndex}\">\n          <template v-if=\"model\">\n            {{ model.name }}\n            <span class=\"layers\">\n              [\n              <template v-for=\"(layer) in model.layers\">{{layer.units}} {{layer.activation}}, </template>\n              ]\n            </span>{{model.highscore||\"\"}} (t: {{model.trainings}})\n          </template>\n        </li>\n      </ul>\n    </div>\n  </div>\n</template>\n\n<script>\n\nconst tf = require('@tensorflow/tfjs');\n\nexport default {\n  name: 'App',\n  data() {\n    return {\n      ctx: null,\n      worldWidth: 256,\n      worldHeight: 256,\n      imgWorld: null,\n      worldLoaded: false,\n      fps: null,\n      fpsCounter: null,\n      tick: true,\n      tickTime: null,\n      duration: -1,\n      durationString: null,\n      car: {\n        width: 8,\n        length: 16,\n        x: 256 / 2 * 0.25,\n        y: 256 / 2 * 1.5,\n        speed: 0.5,\n        steeringSpeed: 0.025,\n        angle: 0\n      },\n      viewSize: 32,\n      viewReduction: 4,\n      viewReducedSize: null,\n      viewPixels: null,\n      steering: null,\n      samples: [],\n      samplesMaxLength: 4096,\n      trainingSamples: null,\n      trainingSamplesMaxLength: 4096,\n      badRewards: 0,\n      badRewardsInARow: 0,\n      score: 0,\n      lastScore: null,\n      highscores: [],\n      highscoresMaxLength: 10,\n      highscoresMaxShown: 10,\n      training: false,\n      trainingProgress: 0,\n      models: undefined,\n      numberOfModels: 5,\n      modelIndex: 0\n    }\n  },\n  computed: {\n    reducedViewSize() {\n      let reducedSize = this.viewSize;\n      for( let i = 0; i < this.viewReduction; i++ ) {\n        reducedSize = reducedSize / 2;\n      }\n      return reducedSize;\n    },\n    highscoresShown() {\n      return this.highscores.slice(0,this.highscoresMaxShown);\n    }\n  },\n  mounted() {\n    this.ctx = this.$refs.canvas.getContext(\"2d\");\n    this.imgWorld = new Image(this.worldWidth,this.worldHeight);\n    this.imgWorld.src = require('/src/assets/world4.jpg');\n    const app = this;\n    this.imgWorld.onload = function() {\n      app.worldLoaded = true;\n    }\n    //document.addEventListener('keydown', this.keyDown);\n    //document.addEventListener('keyup', this.keyUp);\n\n    this.ctxViewSnapshot = this.$refs.viewSnapshotCanvas.getContext(\"2d\");\n    this.ctxCarSnapshot = this.$refs.carSnapshotCanvas.getContext(\"2d\");\n\n    this.ctxCar = this.$refs.carCanvas.getContext(\"2d\");\n    this.ctxView = this.$refs.viewCanvas.getContext(\"2d\");\n    this.ctxViewReduced = this.$refs.viewCanvasReduced.getContext(\"2d\");\n\n    this.ctxStats = this.$refs.statsCanvas.getContext(\"2d\");\n\n\n    this.viewReducedSize = this.viewSize;\n    for( let i = 0; i < this.viewReduction; i++ ) {\n      this.viewReducedSize = this.viewReducedSize / 2;\n    }\n\n    this.models = new Array(this.numberOfModels);\n    this.createModel(this.modelIndex);\n\n    this.refreshLoop();\n  },\n  methods: {\n    createModel( modelIndex ) {\n      console.log(\"creating model ...\");\n      const numberOfLayers =  2;\n      let layers = new Array( numberOfLayers );\n      for( let i = numberOfLayers-1; i >= 0; i-- ) {\n        if( i === numberOfLayers-1 ) {\n          // last layer\n          layers[i] = {\n            units: 1,\n            activation: \"sigmoid\"\n          };\n        }\n        else {\n          layers[i] = {\n            units: 3 + Math.ceil( Math.random()*15 ),\n            activation: [\"relu\",\"sigmoid\"][Math.round(Math.random())]\n          };\n        }\n      }\n      this.models[modelIndex] = {\n        layers: layers,\n        trainings: 0,\n        highscore: undefined,\n        name: modelIndex+1,\n        children: 0\n      };\n\n      // create model with layers\n      this.models[modelIndex].model = tf.sequential();\n      for( let i = 0; i < layers.length; i++ ) {\n        if( i === 0 ) {\n          // first layer\n          this.models[modelIndex].model.add(tf.layers.dense({inputShape: this.viewReducedSize*this.viewReducedSize, activation: layers[i].activation, units: layers[i].units}));\n        }\n        else {\n          this.models[modelIndex].model.add(tf.layers.dense({activation: layers[i].activation, units: layers[i].units}));\n        }\n      }\n      /*\n      this.models[i].model.add(tf.layers.dense({inputShape: this.viewReducedSize*this.viewReducedSize, activation: \"relu\", units: 10}));\n      this.models[i].model.add(tf.layers.dense({activation: \"relu\", units: 5}));\n      this.models[i].model.add(tf.layers.dense({activation: \"sigmoid\", units: 1}));\n      */\n      //this.models[i].add(tf.layers.dense({activation: \"relu\", units: 1}));\n      this.models[modelIndex].model.compile({loss:'binaryCrossentropy',optimizer:tf.train.rmsprop(0.1),metrics:['accuracy']});\n      //this.model.compile({loss:'categoricalCrossentropy',optimizer:tf.train.adam(),metrics:['accuracy']});\n    },\n    async train() {\n\n      // check if new highscore:\n      let highscoreOfModel = this.highscores.find(el => el.modelIndex === this.modelIndex );\n      if( highscoreOfModel ) {\n        this.models[this.modelIndex].highscore = highscoreOfModel.score;\n      }\n\n      // switch to next model\n      this.modelIndex = (this.modelIndex +1) % this.numberOfModels;\n\n      // create or make clone, if necessary\n      if( !this.models[this.modelIndex] ) {\n        this.createModel(this.modelIndex);\n      }\n      else {\n        // check for new highscore\n        let highscoreOfModel = this.highscores.find(el => el.modelIndex === this.modelIndex );\n        if( !highscoreOfModel ) {\n          // replace model\n\n          let random = Math.random();\n          let highscoreIndex;\n          if( random > 1-0.182 ) {\n            highscoreIndex = 0;\n          }\n          else if( random > 1 - 0.182 - 0.163) {\n            highscoreIndex = 1;\n          }\n          else if( random > 1 - 0.182 - 0.163 - 0.146 ) {\n            highscoreIndex = 2;\n          }\n          else if( random > 1 - 0.182 - 0.163 - 0.146 - 0.127 ) {\n            highscoreIndex = 3;\n          }\n          else if( random > 1 - 0.182 - 0.163 - 0.146 - 0.127 - 0.109 ) {\n            highscoreIndex = 4;\n          }\n          else if( random > 1 - 0.182 - 0.163 - 0.146 - 0.127 - 0.109 - 0.091 ) {\n            highscoreIndex = 5;\n          }\n          else if( random > 1 - 0.182 - 0.163 - 0.146 - 0.127 - 0.109 - 0.091 - 0.073 ) {\n            highscoreIndex = 6;\n          }\n          else if( random > 1 - 0.182 - 0.163 - 0.146 - 0.127 - 0.109 - 0.091 - 0.073 - 0.054 ) {\n            highscoreIndex = 7;\n          }\n          else if( random > 1 - 0.182 - 0.163 - 0.146 - 0.127 - 0.109 - 0.091 - 0.073 - 0.054 - 0.037 ) {\n            highscoreIndex = 8;\n          }\n          else if( random > 1 - 0.182 - 0.163 - 0.146 - 0.127 - 0.109 - 0.091 - 0.073 - 0.054 - 0.037 - 0.018 ) {\n            highscoreIndex = 9;\n          }\n\n          const mother = this.models[ this.highscores[highscoreIndex].modelIndex ];\n          this.models[this.modelIndex] = {...mother};\n          this.models[this.modelIndex].trainings = 0;\n          this.models[this.modelIndex].highscore = undefined;\n          mother.children++;\n          this.models[this.modelIndex].name = mother.name+\".\"+mother.children;\n        }\n\n      }\n\n      this.training = true;\n\n      this.trainingSamples = [];\n      for( let i = 0; i < this.highscores.length; i++ ) {\n        let samples = [];\n        for( let j = 0; j < this.highscores[i].samples.length; j++ ) {\n          if( this.highscores[i].samples[j].reward > 0.5 ) {\n            // use only good rewards\n            samples.push( this.highscores[i].samples[j] );\n          }\n        }\n        this.trainingSamples.push(...samples);\n      }\n      // randomise and slice\n      this.trainingSamples.sort(function(){return 0.5 - Math.random()});\n      this.trainingSamples = this.trainingSamples.slice(0,this.trainingSamplesMaxLength);\n\n      console.log(\"total number of samples: \"+this.trainingSamples.length);\n\n      let featureValuesTraining = [];\n      let labelValuesTraining = [];\n      for( let i = 0; i < this.trainingSamples.length; i++ ) {\n        let featureValueTraining = [...this.trainingSamples[i].state];\n        //featureValueTraining.push( this.trainingSamples[i].reward );\n        featureValuesTraining.push( featureValueTraining );\n        labelValuesTraining.push( this.trainingSamples[i].action );\n      }\n      const featureTensorTraining = tf.tensor2d( featureValuesTraining, [featureValuesTraining.length, featureValuesTraining[0].length] );\n      const labelTensorTraining = tf.tensor2d( labelValuesTraining, [labelValuesTraining.length, 1] );\n\n      console.log(\"train model ...\");\n      await this.trainModel( this.modelIndex, featureTensorTraining, labelTensorTraining, Math.min(10, this.trainingSamplesMaxLength/this.trainingSamples.length)*10 );\n\n      this.training = false;\n      this.trainingProgress = 0;\n\n      this.models[this.modelIndex].trainings += 1;\n    },\n    async trainModel( modelIndex, featureTensorTraining, labelTensorTraining, epochs ) {\n      const ref = this;\n      return this.models[modelIndex].model.fit( featureTensorTraining, labelTensorTraining, {\n        epochs,\n        //validationSplit: 0.2,\n        callbacks: {\n          onEpochEnd: function(epoch) {\n            ref.trainingProgress = Math.round( epoch / epochs * 100 );\n          },\n          onTrainEnd: function() {\n            console.log(\"done\");\n          }\n        }\n      });\n    },\n    async predict( modelIndex, input ) {\n      return tf.tidy( () => {\n        const inputTensor = tf.tensor2d([input],[1, this.viewReducedSize*this.viewReducedSize]);\n        const outputTensor = this.models[modelIndex].model.predict( inputTensor );\n        const outputValue = outputTensor.dataSync();\n\n        return outputValue;\n      });\n    },\n    async getSteering() {\n      this.prediction = await this.predict( this.modelIndex, this.testingDataInput );\n      this.prediction = Math.max( 0, this.prediction  )\n      return this.prediction;\n    },\n    refreshLoop() {\n      window.requestAnimationFrame(() => {\n        const now = performance.now();\n        if( this.tick ) {\n          this.tickTime = now;\n          this.fps = this.fpsCounter;\n          this.fpsCounter = 0;\n          this.tick = false;\n\n          this.duration++;\n          const date = new Date(0);\n          date.setSeconds(this.duration); // specify value for SECONDS here\n          this.durationString = date.toISOString().substr(11, 8);\n        }\n        else {\n          this.fpsCounter++;\n          if( now >= this.tickTime + 1000 ) {\n            this.tick = true;\n          }\n        }\n\n        this.enterFrame();\n\n        this.refreshLoop();\n      });\n    },\n    enterFrame() {\n      if( this.worldLoaded && !this.training ) {\n        this.drawWorld();\n        this.getView();\n        this.moveCar();\n      }\n    },\n    drawStats() {\n      this.ctxStats.clearRect( 0, 0, this.ctxStats.canvas.width, this.ctxStats.canvas.height );\n      //this.ctxStats.fillRect(0, 0, this.ctxStats.canvas.width, this.ctxStats.canvas.height);\n      //this.ctxStats.strokeStyle = \"#ffffff\";\n      const numberOfsamplesDrawn = Math.min(512, this.samples.length);\n      for( let i = 0; i < numberOfsamplesDrawn; i++ ) {\n        /*\n        this.ctxStats.moveTo( this.samples[i].action * this.ctxStats.canvas.width, this.ctxStats.canvas.height/this.samples.length * i );\n        this.ctxStats.lineTo( this.samples[i+1].action * this.ctxStats.canvas.width, this.ctxStats.canvas.height/this.samples.length * (i+1) );\n        */\n        this.ctxStats.beginPath();\n        this.ctxStats.fillStyle = \"#ffffff\";\n        this.ctxStats.arc(this.samples[i].actionPredicted * this.ctxStats.canvas.width, this.ctxStats.canvas.height/numberOfsamplesDrawn * i, 1, 0, 2 * Math.PI);\n        this.ctxStats.fill();\n\n        this.ctxStats.beginPath();\n        let rgb;\n        if( this.samples[i].reward >= 0.5 ) {\n          //rgb = \"#00ff00\";\n          rgb = \"#00\"+ Math.round( this.samples[i].reward * 255 ).toString(16) + \"00\";\n          this.ctxStats.fillStyle = rgb;\n          this.ctxStats.arc(this.samples[i].action * this.ctxStats.canvas.width, this.ctxStats.canvas.height/numberOfsamplesDrawn * i, 1, 0, 2 * Math.PI);\n          this.ctxStats.fill();\n        }\n        else {\n          //rgb = \"#ff0000\";\n          rgb = \"#\"+ Math.round( (1-this.samples[i].reward) * 255 ).toString(16) + \"0000\";\n          this.ctxStats.fillStyle = rgb;\n          this.ctxStats.arc(this.samples[i].action * this.ctxStats.canvas.width, this.ctxStats.canvas.height/numberOfsamplesDrawn * i, 1, 0, 2 * Math.PI);\n          this.ctxStats.fill();\n        }\n      }\n      //this.ctxStats.stroke();\n    },\n    moveCar() {\n      this.testingDataInput = [...this.viewPixels];\n      //this.testingDataInput.push(1.0);\n      const ref = this;\n      this.getSteering().then( function(value) {\n        //console.log(\"predicted steering: \"+value);\n        value = Math.min( value, 1 );\n        value = Math.max( value, 0 );\n        //console.log(\"predicted steering: \"+value);\n        ref.car.steeringPredicted = value;\n\n        let randomisation = 0;\n        if( ref.samples[0] ) {\n          if( ref.samples[0].reward < 0.5 ) {\n            randomisation = Math.min( 1, (ref.badRewards/ref.samples.length) * ref.badRewardsInARow );\n          }\n          else {\n            randomisation = 0.05;\n          }\n        }\n        else {\n\n          randomisation = 1;\n        }\n\n        //console.log(\"randomisation: \"+randomisation);\n        const random = Math.random();\n        let randomisedValue = value - randomisation*1 + random * randomisation*2;\n        randomisedValue = Math.min( randomisedValue, 1 );\n        randomisedValue = Math.max( randomisedValue, 0 );\n        ref.car.steering = randomisedValue;\n        //console.log(\"new steering: \"+randomisedValue);\n\n        if( ref.car.steering < 0.5 ) {\n          // left\n          const steeringStrength = (0.5 - ref.car.steering) * 2\n          ref.car.angle -= ref.car.steeringSpeed * steeringStrength;\n        }\n        else if( ref.car.steering > 0.5 ){\n          // right\n          const steeringStrength = (ref.car.steering - 0.5) * 2\n          ref.car.angle += ref.car.steeringSpeed * steeringStrength;\n        }\n\n        ref.car.x += Math.sin( ref.car.angle ) *ref.car.speed;\n        ref.car.y -= Math.cos( ref.car.angle ) *ref.car.speed;\n\n        ref.checkCarCollision();\n      });\n    },\n    getView() {\n      // view\n      this.car.viewX = this.car.x + Math.sin( this.car.angle ) * (this.car.length*0+this.viewSize/2);\n      this.car.viewY = this.car.y - Math.cos( this.car.angle ) * (this.car.length*0+this.viewSize/2);\n      // get view image\n      this.snapshotWhereViewIs = this.ctx.getImageData( this.car.viewX - this.ctxViewSnapshot.canvas.width/2, this.car.viewY - this.ctxViewSnapshot.canvas.height/2, this.ctxViewSnapshot.canvas.width, this.ctxViewSnapshot.canvas.height );\n      // read pixels\n      let viewSnapshotPixels = [];\n      for( let i = 0; i < this.snapshotWhereViewIs.data.length; i += 4 ) {\n        const r = this.snapshotWhereViewIs.data[i];\n        const g = this.snapshotWhereViewIs.data[i+1];\n        const b = this.snapshotWhereViewIs.data[i+2];\n        viewSnapshotPixels.push( [r,g,b] );\n      }\n      // draw rotated image\n      this.ctxViewSnapshot.save();\n      this.ctxViewSnapshot.clearRect( 0, 0, this.ctxViewSnapshot.canvas.width, this.ctxViewSnapshot.canvas.height );\n      this.ctxViewSnapshot.translate( this.ctxViewSnapshot.canvas.width/2, this.ctxViewSnapshot.canvas.height/2 );\n      this.ctxViewSnapshot.rotate( -this.car.angle );\n      this.ctxViewSnapshot.translate( -this.ctxViewSnapshot.canvas.width/2, -this.ctxViewSnapshot.canvas.height/2 );\n      for( let y = 0; y < this.ctxViewSnapshot.canvas.height; y++ ) {\n        for( let x = 0; x < this.ctxViewSnapshot.canvas.width; x++ ) {\n          const pixelIndex = y*this.ctxViewSnapshot.canvas.width + x;\n          const color = this.rgbToHex( viewSnapshotPixels[pixelIndex][0], viewSnapshotPixels[pixelIndex][1], viewSnapshotPixels[pixelIndex][2] );\n          this.ctxViewSnapshot.fillStyle = color;\n          this.ctxViewSnapshot.fillRect( x, y, 1.5, 1.5 );\n        }\n      }\n      this.ctxViewSnapshot.restore();\n      // get view image\n      this.imgWhereViewIs = this.ctxViewSnapshot.getImageData( this.ctxViewSnapshot.canvas.width/2 - this.ctxView.canvas.width/2, this.ctxViewSnapshot.canvas.height/2 - this.ctxView.canvas.height/2, this.ctxView.canvas.width, this.ctxView.canvas.height );\n      this.ctxView.putImageData(this.imgWhereViewIs, 0, 0);\n      // read pixels\n      let viewPixels = [];\n      for( let i = 0; i < this.imgWhereViewIs.data.length; i += 4 ) {\n        const r = this.imgWhereViewIs.data[i];\n        const g = this.imgWhereViewIs.data[i+1];\n        const b = this.imgWhereViewIs.data[i+2];\n        viewPixels.push( [r,g,b] );\n      }\n      let viewPixelsReduced = viewPixels;\n      for( let i = 0; i < this.viewReduction; i++ ) {\n        viewPixelsReduced = this.reducePixels( viewPixelsReduced, Math.sqrt(viewPixelsReduced.length) );\n      }\n      // draw reduced view\n      for( let y = 0; y < this.ctxViewReduced.canvas.height; y++ ) {\n        for( let x = 0; x < this.ctxViewReduced.canvas.width; x++ ) {\n          const pixelIndex = y*this.ctxViewReduced.canvas.width + x;\n          const color = this.rgbToHex( viewPixelsReduced[pixelIndex][0], viewPixelsReduced[pixelIndex][1], viewPixelsReduced[pixelIndex][2] );\n          this.ctxViewReduced.fillStyle = color;\n          this.ctxViewReduced.fillRect( x, y, 1.5, 1.5 );\n        }\n      }\n\n      let previousTotalBrightness;\n      // create sample\n      if( this.viewPixels ) {\n        // has previous state\n        this.samples.unshift( {\n          state: this.viewPixels,\n          action: this.car.steering,\n          actionPredicted: this.car.steeringPredicted\n        } );\n        //this.samples = this.samples.slice(0,this.samplesMaxLength);\n        previousTotalBrightness = this.totalBrightness;\n      }\n\n      // save new view pixels\n      this.viewPixels = [];\n      this.totalBrightness = 0;\n      for( let i = 0; i < viewPixelsReduced.length; i++ ) {\n        const brightness = (viewPixelsReduced[i][0] + viewPixelsReduced[i][1] + viewPixelsReduced[i][2]) / 765;\n        this.viewPixels.push( brightness );\n        this.totalBrightness += brightness;\n      }\n      this.totalBrightness = this.totalBrightness / this.viewPixels.length;\n\n      if( this.samples.length ) {\n        const brightnessChange = this.totalBrightness - previousTotalBrightness;\n        console.log(\"---\");\n        //console.log( \"totalBrightness: \"+ this.totalBrightness );\n        //console.log( \"previousTotalBrightness: \"+ previousTotalBrightness );\n        //console.log( \"brightnessChange: \"+ brightnessChange );\n        let reward;\n        if( brightnessChange >= 0 ) {\n          // better\n          if( this.totalBrightness > 0.5 ) {\n            // not so bad situation\n            reward = 1;\n          }\n          else {\n            // bad situation\n            reward = 0.75 + Math.min( 0.25, brightnessChange*10 * this.totalBrightness );\n          }\n          //reward = 1;\n          //console.log(reward+\": better\");\n        }\n        else {\n          // worse\n          if( this.totalBrightness < 0.5 ) {\n            // bad situation\n            reward = 0;\n          }\n          else {\n            // bad situation\n            reward = Math.min( 0.25, Math.abs(brightnessChange)*10 * this.totalBrightness );\n          }\n          reward = 0;\n          //console.log(reward+\": worse\");\n        }\n        this.samples[0].reward = reward;\n\n\n        // calculate total accuarcy\n        if( reward < 0.5 ) {\n          this.badRewards++;\n          this.badRewardsInARow++;\n        }\n        else {\n          this.badRewardsInARow = 0;\n        }\n\n\n        // trim samples:\n        if( this.samples.length === this.samplesMaxLength ) {\n          //console.log(\"max length reached: \"+this.samples.length);\n          if( this.samples[this.samples.length-1].reward < 0.5 ) {\n            //console.log(\"last is badReward\");\n            this.badRewards--;\n          }\n          //console.log(\"remove\");\n          this.samples = this.samples.slice(0,this.samplesMaxLength-1);\n          //console.log(\"new length: \" +this.samples.length);\n        }\n        console.log( \"good samples: \"+(this.samples.length-this.badRewards) +\" of \"+this.samples.length);\n\n      }\n      else {\n        // first cycle\n        this.badRewards = 0;\n        this.badRewardsInARow = 0;\n      }\n\n    },\n    checkCarCollision() {\n      // get car image\n      this.snapshotWhereCarIs = this.ctx.getImageData( this.car.x - this.ctxCarSnapshot.canvas.width/2, this.car.y - this.ctxCarSnapshot.canvas.height/2, this.ctxCarSnapshot.canvas.width, this.ctxCarSnapshot.canvas.height );\n      // read pixels\n      let carSnapshotPixels = [];\n      for( let i = 0; i < this.snapshotWhereCarIs.data.length; i += 4 ) {\n        const r = this.snapshotWhereCarIs.data[i];\n        const g = this.snapshotWhereCarIs.data[i+1];\n        const b = this.snapshotWhereCarIs.data[i+2];\n        carSnapshotPixels.push( [r,g,b] );\n      }\n      // draw rotated image\n      this.ctxCarSnapshot.save();\n      this.ctxCarSnapshot.clearRect( 0, 0, this.ctxCarSnapshot.canvas.width, this.ctxCarSnapshot.canvas.height );\n      this.ctxCarSnapshot.translate( this.ctxCarSnapshot.canvas.width/2, this.ctxCarSnapshot.canvas.height/2 );\n      this.ctxCarSnapshot.rotate( -this.car.angle );\n      this.ctxCarSnapshot.translate( -this.ctxCarSnapshot.canvas.width/2, -this.ctxCarSnapshot.canvas.height/2 );\n      for( let y = 0; y < this.ctxCarSnapshot.canvas.height; y++ ) {\n        for( let x = 0; x < this.ctxCarSnapshot.canvas.width; x++ ) {\n          const pixelIndex = y*this.ctxCarSnapshot.canvas.width + x;\n          const color = this.rgbToHex( carSnapshotPixels[pixelIndex][0], carSnapshotPixels[pixelIndex][1], carSnapshotPixels[pixelIndex][2] );\n          this.ctxCarSnapshot.fillStyle = color;\n          this.ctxCarSnapshot.fillRect( x, y, 1.5, 1.5 );\n        }\n      }\n      this.ctxCarSnapshot.restore();\n      // get car image\n      this.imgWhereCarIs = this.ctxCarSnapshot.getImageData( this.ctxCarSnapshot.canvas.width/2 - this.ctxCar.canvas.width/2, this.ctxCarSnapshot.canvas.height/2 - this.ctxCar.canvas.height/2, this.ctxCar.canvas.width, this.ctxCar.canvas.height );\n      this.ctxCar.putImageData(this.imgWhereCarIs, 0, 0);\n\n\n\n      this.drawCarAndViewSquare();\n\n\n      // read pixels\n      let totalR = 0;\n      let totalG = 0;\n      let totalB = 0;\n      for( let i = 0; i < this.imgWhereCarIs.data.length; i += 4 ) {\n        totalR += this.imgWhereCarIs.data[i];\n        totalG += this.imgWhereCarIs.data[i+1];\n        totalB += this.imgWhereCarIs.data[i+2];\n      }\n      totalR = Math.round( totalR / (this.imgWhereCarIs.data.length /4) );\n      totalG = Math.round( totalG / (this.imgWhereCarIs.data.length /4) );\n      totalB = Math.round( totalB / (this.imgWhereCarIs.data.length /4) );\n      if( totalR + totalG + totalB < 760 ) {\n        console.log(\"collision!\");\n\n        this.viewPixels = null;\n        this.car.steering = undefined;\n        this.resetCar();\n\n        if( this.highscores.length < this.highscoresMaxLength || this.score > this.highscores[this.highscoresMaxLength-1].score ) {\n          console.log(\"new highscore\");\n\n          this.highscores.push( {\n            score: this.score,\n            samples: [...this.samples],\n            modelIndex: this.modelIndex\n          } );\n          this.highscores.sort(function(a, b){return b.score - a.score});\n          this.highscores = this.highscores.slice(0,this.highscoresMaxLength);\n        }\n        console.log(\"train\");\n        this.train();\n\n        this.drawStats();\n\n        this.samples = [];\n        this.lastScore = this.score;\n        this.score = 0;\n\n        //this.refreshLoop = null;\n      }\n      else {\n        this.score++;\n        this.drawStats();\n      }\n    },\n    drawCarAndViewSquare() {\n      // draw car\n      this.ctx.save();\n      this.ctx.translate( this.car.x, this.car.y );\n      this.ctx.rotate( this.car.angle );\n      this.ctx.translate( -this.car.x, -this.car.y );\n      this.ctx.fillRect( this.car.x -this.car.width/2, this.car.y -this.car.length/2, this.car.width, this.car.length );\n      this.ctx.restore();\n\n      // draw view rect\n      this.ctx.save();\n      this.ctx.translate( this.car.viewX, this.car.viewY );\n      this.ctx.rotate( this.car.angle );\n      this.ctx.translate( -this.car.viewX, -this.car.viewY );\n      this.ctx.strokeStyle = \"#ff0000\";\n      this.ctx.beginPath();\n      this.ctx.rect( this.car.viewX -this.ctxView.canvas.width/2, this.car.viewY -this.ctxView.canvas.height/2, this.ctxView.canvas.width, this.ctxView.canvas.height );\n      this.ctx.stroke();\n      this.ctx.restore();\n    },\n    componentToHex(c) {\n      var hex = c.toString(16);\n      return hex.length == 1 ? \"0\" + hex : hex;\n    },\n    rgbToHex(r, g, b) {\n      return \"#\" + this.componentToHex(r) + this.componentToHex(g) + this.componentToHex(b);\n    },\n    reducePixels(pixels,size) {\n      // reduce resolution\n      let pixelsReduced = [];\n      for( let y = 0; y < size; y+=2 ) {\n        for( let x = 0; x < size; x+=2 ) {\n          const pixelIndexes = [\n            y*size + x,\n            y*size + x +1,\n            (y+1)*size + x,\n            (y+1)*size + x +1,\n          ];\n\n          let totalR = 0;\n          let totalG = 0;\n          let totalB = 0;\n          for( let i = 0; i < pixelIndexes.length; i++ ) {\n            totalR += pixels[pixelIndexes[i]][0];\n            totalG += pixels[pixelIndexes[i]][1];\n            totalB += pixels[pixelIndexes[i]][2];\n          }\n          totalR = Math.round( totalR / pixelIndexes.length );\n          totalG = Math.round( totalG / pixelIndexes.length );\n          totalB = Math.round( totalB / pixelIndexes.length );\n          pixelsReduced.push( [totalR,totalG,totalB] );\n        }\n      }\n      return pixelsReduced;\n    },\n    drawWorld() {\n      this.ctx.clearRect( 0, 0, this.ctx.canvas.width, this.ctx.canvas.height );\n      this.ctx.drawImage( this.imgWorld, 0, 0, this.ctx.canvas.width, this.ctx.canvas.height );\n    },\n    resetCar() {\n      console.log( \"reset car\");\n      this.car.x = this.worldWidth / 2 * 0.25;\n      this.car.y = this.worldHeight / 2 * 1.5;\n      this.car.angle = 0;\n    },\n    /*\n    keyDown(e) {\n      if( e.code === \"ArrowLeft\" ) {\n        this.car.steering = 0;\n      }\n      else if( e.code === \"ArrowRight\" ) {\n        this.car.steering = 1;\n      }\n    },\n    keyUp(e) {\n      if( e.code === \"ArrowLeft\" ) {\n        this.car.steering = undefined;\n      }\n      else if( e.code === \"ArrowRight\" ) {\n        this.car.steering = undefined;\n      }\n    }\n    */\n  }\n}\n</script>\n\n<style lang=\"scss\">\n\nbody {\n  margin: 0;\n  height: 100vh;\n  font-family: sans-serif;\n  font-size: 16px;\n  line-height: 150%;\n  background-color: black;\n  color: white;\n}\nlabel {\n  font-size: 13px;\n}\n#app {\n  height: 100%;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  margin: auto;\n  max-width: 100vh;\n}\n\n.world {\n  position: relative;\n  width: 100%;\n  height: 0;\n  padding-top: 100%;\n  .world-canvas {\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n  }\n  .training {\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    width: 20%;\n    height: 20%;\n    position: absolute;\n    top: 40%;\n    left: 40%;\n    span {\n      text-align: center;\n    }\n  }\n}\n\n\n.car-snapshot-canvas {\n  position: absolute;\n  top: 8px;\n  left: 8px;\n  border: 1px solid white;\n  image-rendering: pixelated;\n  width: 10%;\n  display: none;\n}\n.car-canvas {\n  position: absolute;\n  bottom: 8px;\n  left: 8px;\n  border: 1px solid white;\n  image-rendering: pixelated;\n  width: 15%;\n  display: none;\n}\n.view-snapshot-canvas {\n  position: absolute;\n  top: 8px;\n  right: 8px;\n  border: 1px solid white;\n  image-rendering: pixelated;\n  width: 10%;\n  display: none;\n}\n.view-canvas {\n  position: absolute;\n  bottom: 8px;\n  right: 8px;\n  border: 1px solid white;\n  image-rendering: pixelated;\n  width: 10%;\n  display: none;\n}\n.view-canvas-reduced {\n  position: absolute;\n  bottom: 8px;\n  right: 8px;\n  border: 1px solid red;\n  image-rendering: pixelated;\n  width: 15%;\n}\n\n\n\n.fps {\n  position: absolute;\n  top: 8px;\n  left: 50%;\n  color: #333333;\n}\n\n.highscores {\n  position: absolute;\n  top: 16px;\n  right: 16px;\n  text-align: right;\n\n  .duration {\n    margin-bottom: 16px;\n  }\n\n  label {\n    display: block;\n    font-weight: bold;\n    margin-bottom: 8px;\n  }\n  ul {\n    list-style: none;\n    margin: 0;\n    padding: 0;\n    li {\n      &:first-child {\n        font-size: 20px;\n        line-height: 150%;\n      }\n      &:nth-child(2),\n      &:nth-child(3) {\n        font-size: 16px;\n        line-height: 20px;\n      }\n      display: block;\n      font-size: 13px;\n      line-height: 16px;\n    }\n  }\n\n}\n\n\n.score {\n  position: absolute;\n  right: calc( 15% + 48px);\n  bottom: 48px;\n  text-align: right;\n  label {\n    display: block;\n    font-weight: bold;\n    margin-bottom: 8px;\n  }\n\n  .last {\n    margin-top: 16px;\n    font-size: 25px;\n    label {\n      font-size: 16px;\n    }\n  }\n}\n\n.stats {\n  position: absolute;\n  top: 0;\n  left: 0;\n  height: 100%;\n  .stats-canvas {\n    height: 100%;\n    border-right: 1px solid #333;\n  }\n  &:before {\n    content: '';\n    position: absolute;\n    display: block;\n    width: 50%;\n    height: 100%;\n    border-right: 1px solid #666666;\n  }\n}\n\n.models {\n  position: absolute;\n  top: 0;\n  left: 7.5%;\n  label {\n    display: block;\n    font-weight: bold;\n    margin-bottom: 8px;\n  }\n  ul {\n    list-style: none;\n    padding: 0;\n    margin: 0;\n    li {\n      color: #cccccc;\n      font-size: 13px;\n      line-height: 125%;\n      &.active {\n        font-weight: bold;\n        font-size: 25px;\n      }\n      .layers {\n        font-size: 10px;\n      }\n    }\n  }\n}\n\n</style>\n"]}]}