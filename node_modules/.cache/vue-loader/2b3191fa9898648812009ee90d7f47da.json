{"remainingRequest":"/Users/marceltanner/Google Drive/Kreativs/Interaktiv/Self Driving/vue_2_selfdriving/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/marceltanner/Google Drive/Kreativs/Interaktiv/Self Driving/vue_2_selfdriving/src/App.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/marceltanner/Google Drive/Kreativs/Interaktiv/Self Driving/vue_2_selfdriving/src/App.vue","mtime":1662140713216},{"path":"/Users/marceltanner/Google Drive/Kreativs/Interaktiv/Self Driving/vue_2_selfdriving/node_modules/babel-loader/lib/index.js","mtime":1644164857550},{"path":"/Users/marceltanner/Google Drive/Kreativs/Interaktiv/Self Driving/vue_2_selfdriving/node_modules/cache-loader/dist/cjs.js","mtime":1644164856547},{"path":"/Users/marceltanner/Google Drive/Kreativs/Interaktiv/Self Driving/vue_2_selfdriving/node_modules/vue-loader/lib/index.js","mtime":1644164857852}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KCgpjb25zdCB0ZiA9IHJlcXVpcmUoJ0B0ZW5zb3JmbG93L3RmanMnKTsKCmV4cG9ydCBkZWZhdWx0IHsKICBuYW1lOiAnQXBwJywKICBkYXRhKCkgewogICAgcmV0dXJuIHsKICAgICAgY3R4OiBudWxsLAogICAgICB3b3JsZFdpZHRoOiAyNTYsCiAgICAgIHdvcmxkSGVpZ2h0OiAyNTYsCiAgICAgIGltZ1dvcmxkOiBudWxsLAogICAgICB3b3JsZExvYWRlZDogZmFsc2UsCiAgICAgIGZwczogbnVsbCwKICAgICAgZnBzQ291bnRlcjogbnVsbCwKICAgICAgdGljazogdHJ1ZSwKICAgICAgdGlja1RpbWU6IG51bGwsCiAgICAgIGR1cmF0aW9uOiAtMSwKICAgICAgZHVyYXRpb25TdHJpbmc6IG51bGwsCiAgICAgIGNhcjogewogICAgICAgIHdpZHRoOiA4LAogICAgICAgIGxlbmd0aDogMTYsCiAgICAgICAgeDogMjU2IC8gMiAqIDAuMjUsCiAgICAgICAgeTogMjU2IC8gMiAqIDEuNSwKICAgICAgICBzcGVlZDogMC41LAogICAgICAgIHN0ZWVyaW5nU3BlZWQ6IDAuMDI1LAogICAgICAgIGFuZ2xlOiAwCiAgICAgIH0sCiAgICAgIHZpZXdTaXplOiAzMiwKICAgICAgdmlld1JlZHVjdGlvbjogNCwKICAgICAgdmlld1JlZHVjZWRTaXplOiBudWxsLAogICAgICB2aWV3UGl4ZWxzOiBudWxsLAogICAgICBzdGVlcmluZzogbnVsbCwKICAgICAgc2FtcGxlczogW10sCiAgICAgIHNhbXBsZXNNYXhMZW5ndGg6IDQwOTYsCiAgICAgIHRyYWluaW5nU2FtcGxlczogbnVsbCwKICAgICAgdHJhaW5pbmdTYW1wbGVzTWF4TGVuZ3RoOiA0MDk2LAogICAgICBiYWRSZXdhcmRzOiAwLAogICAgICBiYWRSZXdhcmRzSW5BUm93OiAwLAogICAgICBzY29yZTogMCwKICAgICAgbGFzdFNjb3JlOiBudWxsLAogICAgICBoaWdoc2NvcmVzOiBbXSwKICAgICAgaGlnaHNjb3Jlc01heExlbmd0aDogMTAsCiAgICAgIGhpZ2hzY29yZXNNYXhTaG93bjogMTAsCiAgICAgIHRyYWluaW5nOiBmYWxzZSwKICAgICAgdHJhaW5pbmdQcm9ncmVzczogMCwKICAgICAgbW9kZWxzOiB1bmRlZmluZWQsCiAgICAgIG51bWJlck9mTW9kZWxzOiA1LAogICAgICBtb2RlbEluZGV4OiAwCiAgICB9CiAgfSwKICBjb21wdXRlZDogewogICAgcmVkdWNlZFZpZXdTaXplKCkgewogICAgICBsZXQgcmVkdWNlZFNpemUgPSB0aGlzLnZpZXdTaXplOwogICAgICBmb3IoIGxldCBpID0gMDsgaSA8IHRoaXMudmlld1JlZHVjdGlvbjsgaSsrICkgewogICAgICAgIHJlZHVjZWRTaXplID0gcmVkdWNlZFNpemUgLyAyOwogICAgICB9CiAgICAgIHJldHVybiByZWR1Y2VkU2l6ZTsKICAgIH0sCiAgICBoaWdoc2NvcmVzU2hvd24oKSB7CiAgICAgIHJldHVybiB0aGlzLmhpZ2hzY29yZXMuc2xpY2UoMCx0aGlzLmhpZ2hzY29yZXNNYXhTaG93bik7CiAgICB9CiAgfSwKICBtb3VudGVkKCkgewogICAgdGhpcy5jdHggPSB0aGlzLiRyZWZzLmNhbnZhcy5nZXRDb250ZXh0KCIyZCIpOwogICAgdGhpcy5pbWdXb3JsZCA9IG5ldyBJbWFnZSh0aGlzLndvcmxkV2lkdGgsdGhpcy53b3JsZEhlaWdodCk7CiAgICB0aGlzLmltZ1dvcmxkLnNyYyA9IHJlcXVpcmUoJy9zcmMvYXNzZXRzL3dvcmxkNC5qcGcnKTsKICAgIGNvbnN0IGFwcCA9IHRoaXM7CiAgICB0aGlzLmltZ1dvcmxkLm9ubG9hZCA9IGZ1bmN0aW9uKCkgewogICAgICBhcHAud29ybGRMb2FkZWQgPSB0cnVlOwogICAgfQogICAgLy9kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5rZXlEb3duKTsKICAgIC8vZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCB0aGlzLmtleVVwKTsKCiAgICB0aGlzLmN0eFZpZXdTbmFwc2hvdCA9IHRoaXMuJHJlZnMudmlld1NuYXBzaG90Q2FudmFzLmdldENvbnRleHQoIjJkIik7CiAgICB0aGlzLmN0eENhclNuYXBzaG90ID0gdGhpcy4kcmVmcy5jYXJTbmFwc2hvdENhbnZhcy5nZXRDb250ZXh0KCIyZCIpOwoKICAgIHRoaXMuY3R4Q2FyID0gdGhpcy4kcmVmcy5jYXJDYW52YXMuZ2V0Q29udGV4dCgiMmQiKTsKICAgIHRoaXMuY3R4VmlldyA9IHRoaXMuJHJlZnMudmlld0NhbnZhcy5nZXRDb250ZXh0KCIyZCIpOwogICAgdGhpcy5jdHhWaWV3UmVkdWNlZCA9IHRoaXMuJHJlZnMudmlld0NhbnZhc1JlZHVjZWQuZ2V0Q29udGV4dCgiMmQiKTsKCiAgICB0aGlzLmN0eFN0YXRzID0gdGhpcy4kcmVmcy5zdGF0c0NhbnZhcy5nZXRDb250ZXh0KCIyZCIpOwoKCiAgICB0aGlzLnZpZXdSZWR1Y2VkU2l6ZSA9IHRoaXMudmlld1NpemU7CiAgICBmb3IoIGxldCBpID0gMDsgaSA8IHRoaXMudmlld1JlZHVjdGlvbjsgaSsrICkgewogICAgICB0aGlzLnZpZXdSZWR1Y2VkU2l6ZSA9IHRoaXMudmlld1JlZHVjZWRTaXplIC8gMjsKICAgIH0KCiAgICB0aGlzLm1vZGVscyA9IG5ldyBBcnJheSh0aGlzLm51bWJlck9mTW9kZWxzKTsKICAgIHRoaXMuY3JlYXRlTW9kZWwodGhpcy5tb2RlbEluZGV4KTsKCiAgICB0aGlzLnJlZnJlc2hMb29wKCk7CiAgfSwKICBtZXRob2RzOiB7CiAgICBjcmVhdGVNb2RlbCggbW9kZWxJbmRleCApIHsKICAgICAgY29uc29sZS5sb2coImNyZWF0aW5nIG1vZGVsIC4uLiIpOwogICAgICBjb25zdCBudW1iZXJPZkxheWVycyA9ICAyOwogICAgICBsZXQgbGF5ZXJzID0gbmV3IEFycmF5KCBudW1iZXJPZkxheWVycyApOwogICAgICBmb3IoIGxldCBpID0gbnVtYmVyT2ZMYXllcnMtMTsgaSA+PSAwOyBpLS0gKSB7CiAgICAgICAgaWYoIGkgPT09IG51bWJlck9mTGF5ZXJzLTEgKSB7CiAgICAgICAgICAvLyBsYXN0IGxheWVyCiAgICAgICAgICBsYXllcnNbaV0gPSB7CiAgICAgICAgICAgIHVuaXRzOiAxLAogICAgICAgICAgICBhY3RpdmF0aW9uOiAic2lnbW9pZCIKICAgICAgICAgIH07CiAgICAgICAgfQogICAgICAgIGVsc2UgewogICAgICAgICAgbGF5ZXJzW2ldID0gewogICAgICAgICAgICB1bml0czogMyArIE1hdGguY2VpbCggTWF0aC5yYW5kb20oKSoxNSApLAogICAgICAgICAgICBhY3RpdmF0aW9uOiBbInJlbHUiLCJzaWdtb2lkIl1bTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpKV0KICAgICAgICAgIH07CiAgICAgICAgfQogICAgICB9CiAgICAgIHRoaXMubW9kZWxzW21vZGVsSW5kZXhdID0gewogICAgICAgIGxheWVyczogbGF5ZXJzLAogICAgICAgIHRyYWluaW5nczogMCwKICAgICAgICBoaWdoc2NvcmU6IHVuZGVmaW5lZCwKICAgICAgICBuYW1lOiBtb2RlbEluZGV4KzEsCiAgICAgICAgY2hpbGRyZW46IDAKICAgICAgfTsKCiAgICAgIC8vIGNyZWF0ZSBtb2RlbCB3aXRoIGxheWVycwogICAgICB0aGlzLm1vZGVsc1ttb2RlbEluZGV4XS5tb2RlbCA9IHRmLnNlcXVlbnRpYWwoKTsKICAgICAgZm9yKCBsZXQgaSA9IDA7IGkgPCBsYXllcnMubGVuZ3RoOyBpKysgKSB7CiAgICAgICAgaWYoIGkgPT09IDAgKSB7CiAgICAgICAgICAvLyBmaXJzdCBsYXllcgogICAgICAgICAgdGhpcy5tb2RlbHNbbW9kZWxJbmRleF0ubW9kZWwuYWRkKHRmLmxheWVycy5kZW5zZSh7aW5wdXRTaGFwZTogdGhpcy52aWV3UmVkdWNlZFNpemUqdGhpcy52aWV3UmVkdWNlZFNpemUsIGFjdGl2YXRpb246IGxheWVyc1tpXS5hY3RpdmF0aW9uLCB1bml0czogbGF5ZXJzW2ldLnVuaXRzfSkpOwogICAgICAgIH0KICAgICAgICBlbHNlIHsKICAgICAgICAgIHRoaXMubW9kZWxzW21vZGVsSW5kZXhdLm1vZGVsLmFkZCh0Zi5sYXllcnMuZGVuc2Uoe2FjdGl2YXRpb246IGxheWVyc1tpXS5hY3RpdmF0aW9uLCB1bml0czogbGF5ZXJzW2ldLnVuaXRzfSkpOwogICAgICAgIH0KICAgICAgfQogICAgICAvKgogICAgICB0aGlzLm1vZGVsc1tpXS5tb2RlbC5hZGQodGYubGF5ZXJzLmRlbnNlKHtpbnB1dFNoYXBlOiB0aGlzLnZpZXdSZWR1Y2VkU2l6ZSp0aGlzLnZpZXdSZWR1Y2VkU2l6ZSwgYWN0aXZhdGlvbjogInJlbHUiLCB1bml0czogMTB9KSk7CiAgICAgIHRoaXMubW9kZWxzW2ldLm1vZGVsLmFkZCh0Zi5sYXllcnMuZGVuc2Uoe2FjdGl2YXRpb246ICJyZWx1IiwgdW5pdHM6IDV9KSk7CiAgICAgIHRoaXMubW9kZWxzW2ldLm1vZGVsLmFkZCh0Zi5sYXllcnMuZGVuc2Uoe2FjdGl2YXRpb246ICJzaWdtb2lkIiwgdW5pdHM6IDF9KSk7CiAgICAgICovCiAgICAgIC8vdGhpcy5tb2RlbHNbaV0uYWRkKHRmLmxheWVycy5kZW5zZSh7YWN0aXZhdGlvbjogInJlbHUiLCB1bml0czogMX0pKTsKICAgICAgdGhpcy5tb2RlbHNbbW9kZWxJbmRleF0ubW9kZWwuY29tcGlsZSh7bG9zczonYmluYXJ5Q3Jvc3NlbnRyb3B5JyxvcHRpbWl6ZXI6dGYudHJhaW4ucm1zcHJvcCgwLjEpLG1ldHJpY3M6WydhY2N1cmFjeSddfSk7CiAgICAgIC8vdGhpcy5tb2RlbC5jb21waWxlKHtsb3NzOidjYXRlZ29yaWNhbENyb3NzZW50cm9weScsb3B0aW1pemVyOnRmLnRyYWluLmFkYW0oKSxtZXRyaWNzOlsnYWNjdXJhY3knXX0pOwogICAgfSwKICAgIGFzeW5jIHRyYWluKCkgewoKICAgICAgLy8gY2hlY2sgaWYgbmV3IGhpZ2hzY29yZToKICAgICAgbGV0IGhpZ2hzY29yZU9mTW9kZWwgPSB0aGlzLmhpZ2hzY29yZXMuZmluZChlbCA9PiBlbC5tb2RlbEluZGV4ID09PSB0aGlzLm1vZGVsSW5kZXggKTsKICAgICAgaWYoIGhpZ2hzY29yZU9mTW9kZWwgKSB7CiAgICAgICAgdGhpcy5tb2RlbHNbdGhpcy5tb2RlbEluZGV4XS5oaWdoc2NvcmUgPSBoaWdoc2NvcmVPZk1vZGVsLnNjb3JlOwogICAgICB9CgogICAgICAvLyBzd2l0Y2ggdG8gbmV4dCBtb2RlbAogICAgICB0aGlzLm1vZGVsSW5kZXggPSAodGhpcy5tb2RlbEluZGV4ICsxKSAlIHRoaXMubnVtYmVyT2ZNb2RlbHM7CgogICAgICAvLyBjcmVhdGUgb3IgbWFrZSBjbG9uZSwgaWYgbmVjZXNzYXJ5CiAgICAgIGlmKCAhdGhpcy5tb2RlbHNbdGhpcy5tb2RlbEluZGV4XSApIHsKICAgICAgICB0aGlzLmNyZWF0ZU1vZGVsKHRoaXMubW9kZWxJbmRleCk7CiAgICAgIH0KICAgICAgZWxzZSB7CiAgICAgICAgLy8gY2hlY2sgZm9yIG5ldyBoaWdoc2NvcmUKICAgICAgICBsZXQgaGlnaHNjb3JlT2ZNb2RlbCA9IHRoaXMuaGlnaHNjb3Jlcy5maW5kKGVsID0+IGVsLm1vZGVsSW5kZXggPT09IHRoaXMubW9kZWxJbmRleCApOwogICAgICAgIGlmKCAhaGlnaHNjb3JlT2ZNb2RlbCApIHsKICAgICAgICAgIC8vIHJlcGxhY2UgbW9kZWwKCiAgICAgICAgICBsZXQgcmFuZG9tID0gTWF0aC5yYW5kb20oKTsKICAgICAgICAgIGxldCBoaWdoc2NvcmVJbmRleDsKICAgICAgICAgIGlmKCByYW5kb20gPiAxLTAuMTgyICkgewogICAgICAgICAgICBoaWdoc2NvcmVJbmRleCA9IDA7CiAgICAgICAgICB9CiAgICAgICAgICBlbHNlIGlmKCByYW5kb20gPiAxIC0gMC4xODIgLSAwLjE2MykgewogICAgICAgICAgICBoaWdoc2NvcmVJbmRleCA9IDE7CiAgICAgICAgICB9CiAgICAgICAgICBlbHNlIGlmKCByYW5kb20gPiAxIC0gMC4xODIgLSAwLjE2MyAtIDAuMTQ2ICkgewogICAgICAgICAgICBoaWdoc2NvcmVJbmRleCA9IDI7CiAgICAgICAgICB9CiAgICAgICAgICBlbHNlIGlmKCByYW5kb20gPiAxIC0gMC4xODIgLSAwLjE2MyAtIDAuMTQ2IC0gMC4xMjcgKSB7CiAgICAgICAgICAgIGhpZ2hzY29yZUluZGV4ID0gMzsKICAgICAgICAgIH0KICAgICAgICAgIGVsc2UgaWYoIHJhbmRvbSA+IDEgLSAwLjE4MiAtIDAuMTYzIC0gMC4xNDYgLSAwLjEyNyAtIDAuMTA5ICkgewogICAgICAgICAgICBoaWdoc2NvcmVJbmRleCA9IDQ7CiAgICAgICAgICB9CiAgICAgICAgICBlbHNlIGlmKCByYW5kb20gPiAxIC0gMC4xODIgLSAwLjE2MyAtIDAuMTQ2IC0gMC4xMjcgLSAwLjEwOSAtIDAuMDkxICkgewogICAgICAgICAgICBoaWdoc2NvcmVJbmRleCA9IDU7CiAgICAgICAgICB9CiAgICAgICAgICBlbHNlIGlmKCByYW5kb20gPiAxIC0gMC4xODIgLSAwLjE2MyAtIDAuMTQ2IC0gMC4xMjcgLSAwLjEwOSAtIDAuMDkxIC0gMC4wNzMgKSB7CiAgICAgICAgICAgIGhpZ2hzY29yZUluZGV4ID0gNjsKICAgICAgICAgIH0KICAgICAgICAgIGVsc2UgaWYoIHJhbmRvbSA+IDEgLSAwLjE4MiAtIDAuMTYzIC0gMC4xNDYgLSAwLjEyNyAtIDAuMTA5IC0gMC4wOTEgLSAwLjA3MyAtIDAuMDU0ICkgewogICAgICAgICAgICBoaWdoc2NvcmVJbmRleCA9IDc7CiAgICAgICAgICB9CiAgICAgICAgICBlbHNlIGlmKCByYW5kb20gPiAxIC0gMC4xODIgLSAwLjE2MyAtIDAuMTQ2IC0gMC4xMjcgLSAwLjEwOSAtIDAuMDkxIC0gMC4wNzMgLSAwLjA1NCAtIDAuMDM3ICkgewogICAgICAgICAgICBoaWdoc2NvcmVJbmRleCA9IDg7CiAgICAgICAgICB9CiAgICAgICAgICBlbHNlIGlmKCByYW5kb20gPiAxIC0gMC4xODIgLSAwLjE2MyAtIDAuMTQ2IC0gMC4xMjcgLSAwLjEwOSAtIDAuMDkxIC0gMC4wNzMgLSAwLjA1NCAtIDAuMDM3IC0gMC4wMTggKSB7CiAgICAgICAgICAgIGhpZ2hzY29yZUluZGV4ID0gOTsKICAgICAgICAgIH0KCiAgICAgICAgICBjb25zdCBtb3RoZXIgPSB0aGlzLm1vZGVsc1sgdGhpcy5oaWdoc2NvcmVzW2hpZ2hzY29yZUluZGV4XS5tb2RlbEluZGV4IF07CiAgICAgICAgICB0aGlzLm1vZGVsc1t0aGlzLm1vZGVsSW5kZXhdID0gey4uLm1vdGhlcn07CiAgICAgICAgICB0aGlzLm1vZGVsc1t0aGlzLm1vZGVsSW5kZXhdLnRyYWluaW5ncyA9IDA7CiAgICAgICAgICB0aGlzLm1vZGVsc1t0aGlzLm1vZGVsSW5kZXhdLmhpZ2hzY29yZSA9IHVuZGVmaW5lZDsKICAgICAgICAgIG1vdGhlci5jaGlsZHJlbisrOwogICAgICAgICAgdGhpcy5tb2RlbHNbdGhpcy5tb2RlbEluZGV4XS5uYW1lID0gbW90aGVyLm5hbWUrIi4iK21vdGhlci5jaGlsZHJlbjsKICAgICAgICB9CgogICAgICB9CgogICAgICB0aGlzLnRyYWluaW5nID0gdHJ1ZTsKCiAgICAgIHRoaXMudHJhaW5pbmdTYW1wbGVzID0gW107CiAgICAgIGZvciggbGV0IGkgPSAwOyBpIDwgdGhpcy5oaWdoc2NvcmVzLmxlbmd0aDsgaSsrICkgewogICAgICAgIGxldCBzYW1wbGVzID0gW107CiAgICAgICAgZm9yKCBsZXQgaiA9IDA7IGogPCB0aGlzLmhpZ2hzY29yZXNbaV0uc2FtcGxlcy5sZW5ndGg7IGorKyApIHsKICAgICAgICAgIGlmKCB0aGlzLmhpZ2hzY29yZXNbaV0uc2FtcGxlc1tqXS5yZXdhcmQgPiAwLjUgKSB7CiAgICAgICAgICAgIC8vIHVzZSBvbmx5IGdvb2QgcmV3YXJkcwogICAgICAgICAgICBzYW1wbGVzLnB1c2goIHRoaXMuaGlnaHNjb3Jlc1tpXS5zYW1wbGVzW2pdICk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHRoaXMudHJhaW5pbmdTYW1wbGVzLnB1c2goLi4uc2FtcGxlcyk7CiAgICAgIH0KICAgICAgLy8gcmFuZG9taXNlIGFuZCBzbGljZQogICAgICB0aGlzLnRyYWluaW5nU2FtcGxlcy5zb3J0KGZ1bmN0aW9uKCl7cmV0dXJuIDAuNSAtIE1hdGgucmFuZG9tKCl9KTsKICAgICAgdGhpcy50cmFpbmluZ1NhbXBsZXMgPSB0aGlzLnRyYWluaW5nU2FtcGxlcy5zbGljZSgwLHRoaXMudHJhaW5pbmdTYW1wbGVzTWF4TGVuZ3RoKTsKCiAgICAgIGNvbnNvbGUubG9nKCJ0b3RhbCBudW1iZXIgb2Ygc2FtcGxlczogIit0aGlzLnRyYWluaW5nU2FtcGxlcy5sZW5ndGgpOwoKICAgICAgbGV0IGZlYXR1cmVWYWx1ZXNUcmFpbmluZyA9IFtdOwogICAgICBsZXQgbGFiZWxWYWx1ZXNUcmFpbmluZyA9IFtdOwogICAgICBmb3IoIGxldCBpID0gMDsgaSA8IHRoaXMudHJhaW5pbmdTYW1wbGVzLmxlbmd0aDsgaSsrICkgewogICAgICAgIGxldCBmZWF0dXJlVmFsdWVUcmFpbmluZyA9IFsuLi50aGlzLnRyYWluaW5nU2FtcGxlc1tpXS5zdGF0ZV07CiAgICAgICAgLy9mZWF0dXJlVmFsdWVUcmFpbmluZy5wdXNoKCB0aGlzLnRyYWluaW5nU2FtcGxlc1tpXS5yZXdhcmQgKTsKICAgICAgICBmZWF0dXJlVmFsdWVzVHJhaW5pbmcucHVzaCggZmVhdHVyZVZhbHVlVHJhaW5pbmcgKTsKICAgICAgICBsYWJlbFZhbHVlc1RyYWluaW5nLnB1c2goIHRoaXMudHJhaW5pbmdTYW1wbGVzW2ldLmFjdGlvbiApOwogICAgICB9CiAgICAgIGNvbnN0IGZlYXR1cmVUZW5zb3JUcmFpbmluZyA9IHRmLnRlbnNvcjJkKCBmZWF0dXJlVmFsdWVzVHJhaW5pbmcsIFtmZWF0dXJlVmFsdWVzVHJhaW5pbmcubGVuZ3RoLCBmZWF0dXJlVmFsdWVzVHJhaW5pbmdbMF0ubGVuZ3RoXSApOwogICAgICBjb25zdCBsYWJlbFRlbnNvclRyYWluaW5nID0gdGYudGVuc29yMmQoIGxhYmVsVmFsdWVzVHJhaW5pbmcsIFtsYWJlbFZhbHVlc1RyYWluaW5nLmxlbmd0aCwgMV0gKTsKCiAgICAgIGNvbnNvbGUubG9nKCJ0cmFpbiBtb2RlbCAuLi4iKTsKICAgICAgYXdhaXQgdGhpcy50cmFpbk1vZGVsKCB0aGlzLm1vZGVsSW5kZXgsIGZlYXR1cmVUZW5zb3JUcmFpbmluZywgbGFiZWxUZW5zb3JUcmFpbmluZywgTWF0aC5taW4oMTAsIHRoaXMudHJhaW5pbmdTYW1wbGVzTWF4TGVuZ3RoL3RoaXMudHJhaW5pbmdTYW1wbGVzLmxlbmd0aCkqMTAgKTsKCiAgICAgIHRoaXMudHJhaW5pbmcgPSBmYWxzZTsKICAgICAgdGhpcy50cmFpbmluZ1Byb2dyZXNzID0gMDsKCiAgICAgIHRoaXMubW9kZWxzW3RoaXMubW9kZWxJbmRleF0udHJhaW5pbmdzICs9IDE7CiAgICB9LAogICAgYXN5bmMgdHJhaW5Nb2RlbCggbW9kZWxJbmRleCwgZmVhdHVyZVRlbnNvclRyYWluaW5nLCBsYWJlbFRlbnNvclRyYWluaW5nLCBlcG9jaHMgKSB7CiAgICAgIGNvbnN0IHJlZiA9IHRoaXM7CiAgICAgIHJldHVybiB0aGlzLm1vZGVsc1ttb2RlbEluZGV4XS5tb2RlbC5maXQoIGZlYXR1cmVUZW5zb3JUcmFpbmluZywgbGFiZWxUZW5zb3JUcmFpbmluZywgewogICAgICAgIGVwb2NocywKICAgICAgICAvL3ZhbGlkYXRpb25TcGxpdDogMC4yLAogICAgICAgIGNhbGxiYWNrczogewogICAgICAgICAgb25FcG9jaEVuZDogZnVuY3Rpb24oZXBvY2gpIHsKICAgICAgICAgICAgcmVmLnRyYWluaW5nUHJvZ3Jlc3MgPSBNYXRoLnJvdW5kKCBlcG9jaCAvIGVwb2NocyAqIDEwMCApOwogICAgICAgICAgfSwKICAgICAgICAgIG9uVHJhaW5FbmQ6IGZ1bmN0aW9uKCkgewogICAgICAgICAgICBjb25zb2xlLmxvZygiZG9uZSIpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfSk7CiAgICB9LAogICAgYXN5bmMgcHJlZGljdCggbW9kZWxJbmRleCwgaW5wdXQgKSB7CiAgICAgIHJldHVybiB0Zi50aWR5KCAoKSA9PiB7CiAgICAgICAgY29uc3QgaW5wdXRUZW5zb3IgPSB0Zi50ZW5zb3IyZChbaW5wdXRdLFsxLCB0aGlzLnZpZXdSZWR1Y2VkU2l6ZSp0aGlzLnZpZXdSZWR1Y2VkU2l6ZV0pOwogICAgICAgIGNvbnN0IG91dHB1dFRlbnNvciA9IHRoaXMubW9kZWxzW21vZGVsSW5kZXhdLm1vZGVsLnByZWRpY3QoIGlucHV0VGVuc29yICk7CiAgICAgICAgY29uc3Qgb3V0cHV0VmFsdWUgPSBvdXRwdXRUZW5zb3IuZGF0YVN5bmMoKTsKCiAgICAgICAgcmV0dXJuIG91dHB1dFZhbHVlOwogICAgICB9KTsKICAgIH0sCiAgICBhc3luYyBnZXRTdGVlcmluZygpIHsKICAgICAgdGhpcy5wcmVkaWN0aW9uID0gYXdhaXQgdGhpcy5wcmVkaWN0KCB0aGlzLm1vZGVsSW5kZXgsIHRoaXMudGVzdGluZ0RhdGFJbnB1dCApOwogICAgICB0aGlzLnByZWRpY3Rpb24gPSBNYXRoLm1heCggMCwgdGhpcy5wcmVkaWN0aW9uICApCiAgICAgIHJldHVybiB0aGlzLnByZWRpY3Rpb247CiAgICB9LAogICAgcmVmcmVzaExvb3AoKSB7CiAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gewogICAgICAgIGNvbnN0IG5vdyA9IHBlcmZvcm1hbmNlLm5vdygpOwogICAgICAgIGlmKCB0aGlzLnRpY2sgKSB7CiAgICAgICAgICB0aGlzLnRpY2tUaW1lID0gbm93OwogICAgICAgICAgdGhpcy5mcHMgPSB0aGlzLmZwc0NvdW50ZXI7CiAgICAgICAgICB0aGlzLmZwc0NvdW50ZXIgPSAwOwogICAgICAgICAgdGhpcy50aWNrID0gZmFsc2U7CgogICAgICAgICAgdGhpcy5kdXJhdGlvbisrOwogICAgICAgICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKDApOwogICAgICAgICAgZGF0ZS5zZXRTZWNvbmRzKHRoaXMuZHVyYXRpb24pOyAvLyBzcGVjaWZ5IHZhbHVlIGZvciBTRUNPTkRTIGhlcmUKICAgICAgICAgIHRoaXMuZHVyYXRpb25TdHJpbmcgPSBkYXRlLnRvSVNPU3RyaW5nKCkuc3Vic3RyKDExLCA4KTsKICAgICAgICB9CiAgICAgICAgZWxzZSB7CiAgICAgICAgICB0aGlzLmZwc0NvdW50ZXIrKzsKICAgICAgICAgIGlmKCBub3cgPj0gdGhpcy50aWNrVGltZSArIDEwMDAgKSB7CiAgICAgICAgICAgIHRoaXMudGljayA9IHRydWU7CiAgICAgICAgICB9CiAgICAgICAgfQoKICAgICAgICB0aGlzLmVudGVyRnJhbWUoKTsKCiAgICAgICAgdGhpcy5yZWZyZXNoTG9vcCgpOwogICAgICB9KTsKICAgIH0sCiAgICBlbnRlckZyYW1lKCkgewogICAgICBpZiggdGhpcy53b3JsZExvYWRlZCAmJiAhdGhpcy50cmFpbmluZyApIHsKICAgICAgICB0aGlzLmRyYXdXb3JsZCgpOwogICAgICAgIHRoaXMuZ2V0VmlldygpOwogICAgICAgIHRoaXMubW92ZUNhcigpOwogICAgICB9CiAgICB9LAogICAgZHJhd1N0YXRzKCkgewogICAgICB0aGlzLmN0eFN0YXRzLmNsZWFyUmVjdCggMCwgMCwgdGhpcy5jdHhTdGF0cy5jYW52YXMud2lkdGgsIHRoaXMuY3R4U3RhdHMuY2FudmFzLmhlaWdodCApOwogICAgICAvL3RoaXMuY3R4U3RhdHMuZmlsbFJlY3QoMCwgMCwgdGhpcy5jdHhTdGF0cy5jYW52YXMud2lkdGgsIHRoaXMuY3R4U3RhdHMuY2FudmFzLmhlaWdodCk7CiAgICAgIC8vdGhpcy5jdHhTdGF0cy5zdHJva2VTdHlsZSA9ICIjZmZmZmZmIjsKICAgICAgY29uc3QgbnVtYmVyT2ZzYW1wbGVzRHJhd24gPSBNYXRoLm1pbig1MTIsIHRoaXMuc2FtcGxlcy5sZW5ndGgpOwogICAgICBmb3IoIGxldCBpID0gMDsgaSA8IG51bWJlck9mc2FtcGxlc0RyYXduOyBpKysgKSB7CiAgICAgICAgLyoKICAgICAgICB0aGlzLmN0eFN0YXRzLm1vdmVUbyggdGhpcy5zYW1wbGVzW2ldLmFjdGlvbiAqIHRoaXMuY3R4U3RhdHMuY2FudmFzLndpZHRoLCB0aGlzLmN0eFN0YXRzLmNhbnZhcy5oZWlnaHQvdGhpcy5zYW1wbGVzLmxlbmd0aCAqIGkgKTsKICAgICAgICB0aGlzLmN0eFN0YXRzLmxpbmVUbyggdGhpcy5zYW1wbGVzW2krMV0uYWN0aW9uICogdGhpcy5jdHhTdGF0cy5jYW52YXMud2lkdGgsIHRoaXMuY3R4U3RhdHMuY2FudmFzLmhlaWdodC90aGlzLnNhbXBsZXMubGVuZ3RoICogKGkrMSkgKTsKICAgICAgICAqLwogICAgICAgIHRoaXMuY3R4U3RhdHMuYmVnaW5QYXRoKCk7CiAgICAgICAgdGhpcy5jdHhTdGF0cy5maWxsU3R5bGUgPSAiI2ZmZmZmZiI7CiAgICAgICAgdGhpcy5jdHhTdGF0cy5hcmModGhpcy5zYW1wbGVzW2ldLmFjdGlvblByZWRpY3RlZCAqIHRoaXMuY3R4U3RhdHMuY2FudmFzLndpZHRoLCB0aGlzLmN0eFN0YXRzLmNhbnZhcy5oZWlnaHQvbnVtYmVyT2ZzYW1wbGVzRHJhd24gKiBpLCAxLCAwLCAyICogTWF0aC5QSSk7CiAgICAgICAgdGhpcy5jdHhTdGF0cy5maWxsKCk7CgogICAgICAgIHRoaXMuY3R4U3RhdHMuYmVnaW5QYXRoKCk7CiAgICAgICAgbGV0IHJnYjsKICAgICAgICBpZiggdGhpcy5zYW1wbGVzW2ldLnJld2FyZCA+PSAwLjUgKSB7CiAgICAgICAgICAvL3JnYiA9ICIjMDBmZjAwIjsKICAgICAgICAgIHJnYiA9ICIjMDAiKyBNYXRoLnJvdW5kKCB0aGlzLnNhbXBsZXNbaV0ucmV3YXJkICogMjU1ICkudG9TdHJpbmcoMTYpICsgIjAwIjsKICAgICAgICAgIHRoaXMuY3R4U3RhdHMuZmlsbFN0eWxlID0gcmdiOwogICAgICAgICAgdGhpcy5jdHhTdGF0cy5hcmModGhpcy5zYW1wbGVzW2ldLmFjdGlvbiAqIHRoaXMuY3R4U3RhdHMuY2FudmFzLndpZHRoLCB0aGlzLmN0eFN0YXRzLmNhbnZhcy5oZWlnaHQvbnVtYmVyT2ZzYW1wbGVzRHJhd24gKiBpLCAxLCAwLCAyICogTWF0aC5QSSk7CiAgICAgICAgICB0aGlzLmN0eFN0YXRzLmZpbGwoKTsKICAgICAgICB9CiAgICAgICAgZWxzZSB7CiAgICAgICAgICAvL3JnYiA9ICIjZmYwMDAwIjsKICAgICAgICAgIHJnYiA9ICIjIisgTWF0aC5yb3VuZCggKDEtdGhpcy5zYW1wbGVzW2ldLnJld2FyZCkgKiAyNTUgKS50b1N0cmluZygxNikgKyAiMDAwMCI7CiAgICAgICAgICB0aGlzLmN0eFN0YXRzLmZpbGxTdHlsZSA9IHJnYjsKICAgICAgICAgIHRoaXMuY3R4U3RhdHMuYXJjKHRoaXMuc2FtcGxlc1tpXS5hY3Rpb24gKiB0aGlzLmN0eFN0YXRzLmNhbnZhcy53aWR0aCwgdGhpcy5jdHhTdGF0cy5jYW52YXMuaGVpZ2h0L251bWJlck9mc2FtcGxlc0RyYXduICogaSwgMSwgMCwgMiAqIE1hdGguUEkpOwogICAgICAgICAgdGhpcy5jdHhTdGF0cy5maWxsKCk7CiAgICAgICAgfQogICAgICB9CiAgICAgIC8vdGhpcy5jdHhTdGF0cy5zdHJva2UoKTsKICAgIH0sCiAgICBtb3ZlQ2FyKCkgewogICAgICB0aGlzLnRlc3RpbmdEYXRhSW5wdXQgPSBbLi4udGhpcy52aWV3UGl4ZWxzXTsKICAgICAgLy90aGlzLnRlc3RpbmdEYXRhSW5wdXQucHVzaCgxLjApOwogICAgICBjb25zdCByZWYgPSB0aGlzOwogICAgICB0aGlzLmdldFN0ZWVyaW5nKCkudGhlbiggZnVuY3Rpb24odmFsdWUpIHsKICAgICAgICAvL2NvbnNvbGUubG9nKCJwcmVkaWN0ZWQgc3RlZXJpbmc6ICIrdmFsdWUpOwogICAgICAgIHZhbHVlID0gTWF0aC5taW4oIHZhbHVlLCAxICk7CiAgICAgICAgdmFsdWUgPSBNYXRoLm1heCggdmFsdWUsIDAgKTsKICAgICAgICAvL2NvbnNvbGUubG9nKCJwcmVkaWN0ZWQgc3RlZXJpbmc6ICIrdmFsdWUpOwogICAgICAgIHJlZi5jYXIuc3RlZXJpbmdQcmVkaWN0ZWQgPSB2YWx1ZTsKCiAgICAgICAgbGV0IHJhbmRvbWlzYXRpb24gPSAwOwogICAgICAgIGlmKCByZWYuc2FtcGxlc1swXSApIHsKICAgICAgICAgIGlmKCByZWYuc2FtcGxlc1swXS5yZXdhcmQgPCAwLjUgKSB7CiAgICAgICAgICAgIHJhbmRvbWlzYXRpb24gPSBNYXRoLm1pbiggMSwgKHJlZi5iYWRSZXdhcmRzL3JlZi5zYW1wbGVzLmxlbmd0aCkgKiByZWYuYmFkUmV3YXJkc0luQVJvdyApOwogICAgICAgICAgfQogICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgIHJhbmRvbWlzYXRpb24gPSAwLjA1OwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBlbHNlIHsKCiAgICAgICAgICByYW5kb21pc2F0aW9uID0gMTsKICAgICAgICB9CgogICAgICAgIC8vY29uc29sZS5sb2coInJhbmRvbWlzYXRpb246ICIrcmFuZG9taXNhdGlvbik7CiAgICAgICAgY29uc3QgcmFuZG9tID0gTWF0aC5yYW5kb20oKTsKICAgICAgICBsZXQgcmFuZG9taXNlZFZhbHVlID0gdmFsdWUgLSByYW5kb21pc2F0aW9uKjEgKyByYW5kb20gKiByYW5kb21pc2F0aW9uKjI7CiAgICAgICAgcmFuZG9taXNlZFZhbHVlID0gTWF0aC5taW4oIHJhbmRvbWlzZWRWYWx1ZSwgMSApOwogICAgICAgIHJhbmRvbWlzZWRWYWx1ZSA9IE1hdGgubWF4KCByYW5kb21pc2VkVmFsdWUsIDAgKTsKICAgICAgICByZWYuY2FyLnN0ZWVyaW5nID0gcmFuZG9taXNlZFZhbHVlOwogICAgICAgIC8vY29uc29sZS5sb2coIm5ldyBzdGVlcmluZzogIityYW5kb21pc2VkVmFsdWUpOwoKICAgICAgICBpZiggcmVmLmNhci5zdGVlcmluZyA8IDAuNSApIHsKICAgICAgICAgIC8vIGxlZnQKICAgICAgICAgIGNvbnN0IHN0ZWVyaW5nU3RyZW5ndGggPSAoMC41IC0gcmVmLmNhci5zdGVlcmluZykgKiAyCiAgICAgICAgICByZWYuY2FyLmFuZ2xlIC09IHJlZi5jYXIuc3RlZXJpbmdTcGVlZCAqIHN0ZWVyaW5nU3RyZW5ndGg7CiAgICAgICAgfQogICAgICAgIGVsc2UgaWYoIHJlZi5jYXIuc3RlZXJpbmcgPiAwLjUgKXsKICAgICAgICAgIC8vIHJpZ2h0CiAgICAgICAgICBjb25zdCBzdGVlcmluZ1N0cmVuZ3RoID0gKHJlZi5jYXIuc3RlZXJpbmcgLSAwLjUpICogMgogICAgICAgICAgcmVmLmNhci5hbmdsZSArPSByZWYuY2FyLnN0ZWVyaW5nU3BlZWQgKiBzdGVlcmluZ1N0cmVuZ3RoOwogICAgICAgIH0KCiAgICAgICAgcmVmLmNhci54ICs9IE1hdGguc2luKCByZWYuY2FyLmFuZ2xlICkgKnJlZi5jYXIuc3BlZWQ7CiAgICAgICAgcmVmLmNhci55IC09IE1hdGguY29zKCByZWYuY2FyLmFuZ2xlICkgKnJlZi5jYXIuc3BlZWQ7CgogICAgICAgIHJlZi5jaGVja0NhckNvbGxpc2lvbigpOwogICAgICB9KTsKICAgIH0sCiAgICBnZXRWaWV3KCkgewogICAgICAvLyB2aWV3CiAgICAgIHRoaXMuY2FyLnZpZXdYID0gdGhpcy5jYXIueCArIE1hdGguc2luKCB0aGlzLmNhci5hbmdsZSApICogKHRoaXMuY2FyLmxlbmd0aCowK3RoaXMudmlld1NpemUvMik7CiAgICAgIHRoaXMuY2FyLnZpZXdZID0gdGhpcy5jYXIueSAtIE1hdGguY29zKCB0aGlzLmNhci5hbmdsZSApICogKHRoaXMuY2FyLmxlbmd0aCowK3RoaXMudmlld1NpemUvMik7CiAgICAgIC8vIGdldCB2aWV3IGltYWdlCiAgICAgIHRoaXMuc25hcHNob3RXaGVyZVZpZXdJcyA9IHRoaXMuY3R4LmdldEltYWdlRGF0YSggdGhpcy5jYXIudmlld1ggLSB0aGlzLmN0eFZpZXdTbmFwc2hvdC5jYW52YXMud2lkdGgvMiwgdGhpcy5jYXIudmlld1kgLSB0aGlzLmN0eFZpZXdTbmFwc2hvdC5jYW52YXMuaGVpZ2h0LzIsIHRoaXMuY3R4Vmlld1NuYXBzaG90LmNhbnZhcy53aWR0aCwgdGhpcy5jdHhWaWV3U25hcHNob3QuY2FudmFzLmhlaWdodCApOwogICAgICAvLyByZWFkIHBpeGVscwogICAgICBsZXQgdmlld1NuYXBzaG90UGl4ZWxzID0gW107CiAgICAgIGZvciggbGV0IGkgPSAwOyBpIDwgdGhpcy5zbmFwc2hvdFdoZXJlVmlld0lzLmRhdGEubGVuZ3RoOyBpICs9IDQgKSB7CiAgICAgICAgY29uc3QgciA9IHRoaXMuc25hcHNob3RXaGVyZVZpZXdJcy5kYXRhW2ldOwogICAgICAgIGNvbnN0IGcgPSB0aGlzLnNuYXBzaG90V2hlcmVWaWV3SXMuZGF0YVtpKzFdOwogICAgICAgIGNvbnN0IGIgPSB0aGlzLnNuYXBzaG90V2hlcmVWaWV3SXMuZGF0YVtpKzJdOwogICAgICAgIHZpZXdTbmFwc2hvdFBpeGVscy5wdXNoKCBbcixnLGJdICk7CiAgICAgIH0KICAgICAgLy8gZHJhdyByb3RhdGVkIGltYWdlCiAgICAgIHRoaXMuY3R4Vmlld1NuYXBzaG90LnNhdmUoKTsKICAgICAgdGhpcy5jdHhWaWV3U25hcHNob3QuY2xlYXJSZWN0KCAwLCAwLCB0aGlzLmN0eFZpZXdTbmFwc2hvdC5jYW52YXMud2lkdGgsIHRoaXMuY3R4Vmlld1NuYXBzaG90LmNhbnZhcy5oZWlnaHQgKTsKICAgICAgdGhpcy5jdHhWaWV3U25hcHNob3QudHJhbnNsYXRlKCB0aGlzLmN0eFZpZXdTbmFwc2hvdC5jYW52YXMud2lkdGgvMiwgdGhpcy5jdHhWaWV3U25hcHNob3QuY2FudmFzLmhlaWdodC8yICk7CiAgICAgIHRoaXMuY3R4Vmlld1NuYXBzaG90LnJvdGF0ZSggLXRoaXMuY2FyLmFuZ2xlICk7CiAgICAgIHRoaXMuY3R4Vmlld1NuYXBzaG90LnRyYW5zbGF0ZSggLXRoaXMuY3R4Vmlld1NuYXBzaG90LmNhbnZhcy53aWR0aC8yLCAtdGhpcy5jdHhWaWV3U25hcHNob3QuY2FudmFzLmhlaWdodC8yICk7CiAgICAgIGZvciggbGV0IHkgPSAwOyB5IDwgdGhpcy5jdHhWaWV3U25hcHNob3QuY2FudmFzLmhlaWdodDsgeSsrICkgewogICAgICAgIGZvciggbGV0IHggPSAwOyB4IDwgdGhpcy5jdHhWaWV3U25hcHNob3QuY2FudmFzLndpZHRoOyB4KysgKSB7CiAgICAgICAgICBjb25zdCBwaXhlbEluZGV4ID0geSp0aGlzLmN0eFZpZXdTbmFwc2hvdC5jYW52YXMud2lkdGggKyB4OwogICAgICAgICAgY29uc3QgY29sb3IgPSB0aGlzLnJnYlRvSGV4KCB2aWV3U25hcHNob3RQaXhlbHNbcGl4ZWxJbmRleF1bMF0sIHZpZXdTbmFwc2hvdFBpeGVsc1twaXhlbEluZGV4XVsxXSwgdmlld1NuYXBzaG90UGl4ZWxzW3BpeGVsSW5kZXhdWzJdICk7CiAgICAgICAgICB0aGlzLmN0eFZpZXdTbmFwc2hvdC5maWxsU3R5bGUgPSBjb2xvcjsKICAgICAgICAgIHRoaXMuY3R4Vmlld1NuYXBzaG90LmZpbGxSZWN0KCB4LCB5LCAxLjUsIDEuNSApOwogICAgICAgIH0KICAgICAgfQogICAgICB0aGlzLmN0eFZpZXdTbmFwc2hvdC5yZXN0b3JlKCk7CiAgICAgIC8vIGdldCB2aWV3IGltYWdlCiAgICAgIHRoaXMuaW1nV2hlcmVWaWV3SXMgPSB0aGlzLmN0eFZpZXdTbmFwc2hvdC5nZXRJbWFnZURhdGEoIHRoaXMuY3R4Vmlld1NuYXBzaG90LmNhbnZhcy53aWR0aC8yIC0gdGhpcy5jdHhWaWV3LmNhbnZhcy53aWR0aC8yLCB0aGlzLmN0eFZpZXdTbmFwc2hvdC5jYW52YXMuaGVpZ2h0LzIgLSB0aGlzLmN0eFZpZXcuY2FudmFzLmhlaWdodC8yLCB0aGlzLmN0eFZpZXcuY2FudmFzLndpZHRoLCB0aGlzLmN0eFZpZXcuY2FudmFzLmhlaWdodCApOwogICAgICB0aGlzLmN0eFZpZXcucHV0SW1hZ2VEYXRhKHRoaXMuaW1nV2hlcmVWaWV3SXMsIDAsIDApOwogICAgICAvLyByZWFkIHBpeGVscwogICAgICBsZXQgdmlld1BpeGVscyA9IFtdOwogICAgICBmb3IoIGxldCBpID0gMDsgaSA8IHRoaXMuaW1nV2hlcmVWaWV3SXMuZGF0YS5sZW5ndGg7IGkgKz0gNCApIHsKICAgICAgICBjb25zdCByID0gdGhpcy5pbWdXaGVyZVZpZXdJcy5kYXRhW2ldOwogICAgICAgIGNvbnN0IGcgPSB0aGlzLmltZ1doZXJlVmlld0lzLmRhdGFbaSsxXTsKICAgICAgICBjb25zdCBiID0gdGhpcy5pbWdXaGVyZVZpZXdJcy5kYXRhW2krMl07CiAgICAgICAgdmlld1BpeGVscy5wdXNoKCBbcixnLGJdICk7CiAgICAgIH0KICAgICAgbGV0IHZpZXdQaXhlbHNSZWR1Y2VkID0gdmlld1BpeGVsczsKICAgICAgZm9yKCBsZXQgaSA9IDA7IGkgPCB0aGlzLnZpZXdSZWR1Y3Rpb247IGkrKyApIHsKICAgICAgICB2aWV3UGl4ZWxzUmVkdWNlZCA9IHRoaXMucmVkdWNlUGl4ZWxzKCB2aWV3UGl4ZWxzUmVkdWNlZCwgTWF0aC5zcXJ0KHZpZXdQaXhlbHNSZWR1Y2VkLmxlbmd0aCkgKTsKICAgICAgfQogICAgICAvLyBkcmF3IHJlZHVjZWQgdmlldwogICAgICBmb3IoIGxldCB5ID0gMDsgeSA8IHRoaXMuY3R4Vmlld1JlZHVjZWQuY2FudmFzLmhlaWdodDsgeSsrICkgewogICAgICAgIGZvciggbGV0IHggPSAwOyB4IDwgdGhpcy5jdHhWaWV3UmVkdWNlZC5jYW52YXMud2lkdGg7IHgrKyApIHsKICAgICAgICAgIGNvbnN0IHBpeGVsSW5kZXggPSB5KnRoaXMuY3R4Vmlld1JlZHVjZWQuY2FudmFzLndpZHRoICsgeDsKICAgICAgICAgIGNvbnN0IGNvbG9yID0gdGhpcy5yZ2JUb0hleCggdmlld1BpeGVsc1JlZHVjZWRbcGl4ZWxJbmRleF1bMF0sIHZpZXdQaXhlbHNSZWR1Y2VkW3BpeGVsSW5kZXhdWzFdLCB2aWV3UGl4ZWxzUmVkdWNlZFtwaXhlbEluZGV4XVsyXSApOwogICAgICAgICAgdGhpcy5jdHhWaWV3UmVkdWNlZC5maWxsU3R5bGUgPSBjb2xvcjsKICAgICAgICAgIHRoaXMuY3R4Vmlld1JlZHVjZWQuZmlsbFJlY3QoIHgsIHksIDEuNSwgMS41ICk7CiAgICAgICAgfQogICAgICB9CgogICAgICBsZXQgcHJldmlvdXNUb3RhbEJyaWdodG5lc3M7CiAgICAgIC8vIGNyZWF0ZSBzYW1wbGUKICAgICAgaWYoIHRoaXMudmlld1BpeGVscyApIHsKICAgICAgICAvLyBoYXMgcHJldmlvdXMgc3RhdGUKICAgICAgICB0aGlzLnNhbXBsZXMudW5zaGlmdCggewogICAgICAgICAgc3RhdGU6IHRoaXMudmlld1BpeGVscywKICAgICAgICAgIGFjdGlvbjogdGhpcy5jYXIuc3RlZXJpbmcsCiAgICAgICAgICBhY3Rpb25QcmVkaWN0ZWQ6IHRoaXMuY2FyLnN0ZWVyaW5nUHJlZGljdGVkCiAgICAgICAgfSApOwogICAgICAgIC8vdGhpcy5zYW1wbGVzID0gdGhpcy5zYW1wbGVzLnNsaWNlKDAsdGhpcy5zYW1wbGVzTWF4TGVuZ3RoKTsKICAgICAgICBwcmV2aW91c1RvdGFsQnJpZ2h0bmVzcyA9IHRoaXMudG90YWxCcmlnaHRuZXNzOwogICAgICB9CgogICAgICAvLyBzYXZlIG5ldyB2aWV3IHBpeGVscwogICAgICB0aGlzLnZpZXdQaXhlbHMgPSBbXTsKICAgICAgdGhpcy50b3RhbEJyaWdodG5lc3MgPSAwOwogICAgICBmb3IoIGxldCBpID0gMDsgaSA8IHZpZXdQaXhlbHNSZWR1Y2VkLmxlbmd0aDsgaSsrICkgewogICAgICAgIGNvbnN0IGJyaWdodG5lc3MgPSAodmlld1BpeGVsc1JlZHVjZWRbaV1bMF0gKyB2aWV3UGl4ZWxzUmVkdWNlZFtpXVsxXSArIHZpZXdQaXhlbHNSZWR1Y2VkW2ldWzJdKSAvIDc2NTsKICAgICAgICB0aGlzLnZpZXdQaXhlbHMucHVzaCggYnJpZ2h0bmVzcyApOwogICAgICAgIHRoaXMudG90YWxCcmlnaHRuZXNzICs9IGJyaWdodG5lc3M7CiAgICAgIH0KICAgICAgdGhpcy50b3RhbEJyaWdodG5lc3MgPSB0aGlzLnRvdGFsQnJpZ2h0bmVzcyAvIHRoaXMudmlld1BpeGVscy5sZW5ndGg7CgogICAgICBpZiggdGhpcy5zYW1wbGVzLmxlbmd0aCApIHsKICAgICAgICBjb25zdCBicmlnaHRuZXNzQ2hhbmdlID0gdGhpcy50b3RhbEJyaWdodG5lc3MgLSBwcmV2aW91c1RvdGFsQnJpZ2h0bmVzczsKICAgICAgICBjb25zb2xlLmxvZygiLS0tIik7CiAgICAgICAgLy9jb25zb2xlLmxvZyggInRvdGFsQnJpZ2h0bmVzczogIisgdGhpcy50b3RhbEJyaWdodG5lc3MgKTsKICAgICAgICAvL2NvbnNvbGUubG9nKCAicHJldmlvdXNUb3RhbEJyaWdodG5lc3M6ICIrIHByZXZpb3VzVG90YWxCcmlnaHRuZXNzICk7CiAgICAgICAgLy9jb25zb2xlLmxvZyggImJyaWdodG5lc3NDaGFuZ2U6ICIrIGJyaWdodG5lc3NDaGFuZ2UgKTsKICAgICAgICBsZXQgcmV3YXJkOwogICAgICAgIGlmKCBicmlnaHRuZXNzQ2hhbmdlID49IDAgKSB7CiAgICAgICAgICAvLyBiZXR0ZXIKICAgICAgICAgIGlmKCB0aGlzLnRvdGFsQnJpZ2h0bmVzcyA+IDAuNSApIHsKICAgICAgICAgICAgLy8gbm90IHNvIGJhZCBzaXR1YXRpb24KICAgICAgICAgICAgcmV3YXJkID0gMTsKICAgICAgICAgIH0KICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAvLyBiYWQgc2l0dWF0aW9uCiAgICAgICAgICAgIHJld2FyZCA9IDAuNzUgKyBNYXRoLm1pbiggMC4yNSwgYnJpZ2h0bmVzc0NoYW5nZSoxMCAqIHRoaXMudG90YWxCcmlnaHRuZXNzICk7CiAgICAgICAgICB9CiAgICAgICAgICAvL3Jld2FyZCA9IDE7CiAgICAgICAgICAvL2NvbnNvbGUubG9nKHJld2FyZCsiOiBiZXR0ZXIiKTsKICAgICAgICB9CiAgICAgICAgZWxzZSB7CiAgICAgICAgICAvLyB3b3JzZQogICAgICAgICAgaWYoIHRoaXMudG90YWxCcmlnaHRuZXNzIDwgMC41ICkgewogICAgICAgICAgICAvLyBiYWQgc2l0dWF0aW9uCiAgICAgICAgICAgIHJld2FyZCA9IDA7CiAgICAgICAgICB9CiAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgLy8gYmFkIHNpdHVhdGlvbgogICAgICAgICAgICByZXdhcmQgPSBNYXRoLm1pbiggMC4yNSwgTWF0aC5hYnMoYnJpZ2h0bmVzc0NoYW5nZSkqMTAgKiB0aGlzLnRvdGFsQnJpZ2h0bmVzcyApOwogICAgICAgICAgfQogICAgICAgICAgcmV3YXJkID0gMDsKICAgICAgICAgIC8vY29uc29sZS5sb2cocmV3YXJkKyI6IHdvcnNlIik7CiAgICAgICAgfQogICAgICAgIHRoaXMuc2FtcGxlc1swXS5yZXdhcmQgPSByZXdhcmQ7CgoKICAgICAgICAvLyBjYWxjdWxhdGUgdG90YWwgYWNjdWFyY3kKICAgICAgICBpZiggcmV3YXJkIDwgMC41ICkgewogICAgICAgICAgdGhpcy5iYWRSZXdhcmRzKys7CiAgICAgICAgICB0aGlzLmJhZFJld2FyZHNJbkFSb3crKzsKICAgICAgICB9CiAgICAgICAgZWxzZSB7CiAgICAgICAgICB0aGlzLmJhZFJld2FyZHNJbkFSb3cgPSAwOwogICAgICAgIH0KCgogICAgICAgIC8vIHRyaW0gc2FtcGxlczoKICAgICAgICBpZiggdGhpcy5zYW1wbGVzLmxlbmd0aCA9PT0gdGhpcy5zYW1wbGVzTWF4TGVuZ3RoICkgewogICAgICAgICAgLy9jb25zb2xlLmxvZygibWF4IGxlbmd0aCByZWFjaGVkOiAiK3RoaXMuc2FtcGxlcy5sZW5ndGgpOwogICAgICAgICAgaWYoIHRoaXMuc2FtcGxlc1t0aGlzLnNhbXBsZXMubGVuZ3RoLTFdLnJld2FyZCA8IDAuNSApIHsKICAgICAgICAgICAgLy9jb25zb2xlLmxvZygibGFzdCBpcyBiYWRSZXdhcmQiKTsKICAgICAgICAgICAgdGhpcy5iYWRSZXdhcmRzLS07CiAgICAgICAgICB9CiAgICAgICAgICAvL2NvbnNvbGUubG9nKCJyZW1vdmUiKTsKICAgICAgICAgIHRoaXMuc2FtcGxlcyA9IHRoaXMuc2FtcGxlcy5zbGljZSgwLHRoaXMuc2FtcGxlc01heExlbmd0aC0xKTsKICAgICAgICAgIC8vY29uc29sZS5sb2coIm5ldyBsZW5ndGg6ICIgK3RoaXMuc2FtcGxlcy5sZW5ndGgpOwogICAgICAgIH0KICAgICAgICBjb25zb2xlLmxvZyggImdvb2Qgc2FtcGxlczogIisodGhpcy5zYW1wbGVzLmxlbmd0aC10aGlzLmJhZFJld2FyZHMpICsiIG9mICIrdGhpcy5zYW1wbGVzLmxlbmd0aCk7CgogICAgICB9CiAgICAgIGVsc2UgewogICAgICAgIC8vIGZpcnN0IGN5Y2xlCiAgICAgICAgdGhpcy5iYWRSZXdhcmRzID0gMDsKICAgICAgICB0aGlzLmJhZFJld2FyZHNJbkFSb3cgPSAwOwogICAgICB9CgogICAgfSwKICAgIGNoZWNrQ2FyQ29sbGlzaW9uKCkgewogICAgICAvLyBnZXQgY2FyIGltYWdlCiAgICAgIHRoaXMuc25hcHNob3RXaGVyZUNhcklzID0gdGhpcy5jdHguZ2V0SW1hZ2VEYXRhKCB0aGlzLmNhci54IC0gdGhpcy5jdHhDYXJTbmFwc2hvdC5jYW52YXMud2lkdGgvMiwgdGhpcy5jYXIueSAtIHRoaXMuY3R4Q2FyU25hcHNob3QuY2FudmFzLmhlaWdodC8yLCB0aGlzLmN0eENhclNuYXBzaG90LmNhbnZhcy53aWR0aCwgdGhpcy5jdHhDYXJTbmFwc2hvdC5jYW52YXMuaGVpZ2h0ICk7CiAgICAgIC8vIHJlYWQgcGl4ZWxzCiAgICAgIGxldCBjYXJTbmFwc2hvdFBpeGVscyA9IFtdOwogICAgICBmb3IoIGxldCBpID0gMDsgaSA8IHRoaXMuc25hcHNob3RXaGVyZUNhcklzLmRhdGEubGVuZ3RoOyBpICs9IDQgKSB7CiAgICAgICAgY29uc3QgciA9IHRoaXMuc25hcHNob3RXaGVyZUNhcklzLmRhdGFbaV07CiAgICAgICAgY29uc3QgZyA9IHRoaXMuc25hcHNob3RXaGVyZUNhcklzLmRhdGFbaSsxXTsKICAgICAgICBjb25zdCBiID0gdGhpcy5zbmFwc2hvdFdoZXJlQ2FySXMuZGF0YVtpKzJdOwogICAgICAgIGNhclNuYXBzaG90UGl4ZWxzLnB1c2goIFtyLGcsYl0gKTsKICAgICAgfQogICAgICAvLyBkcmF3IHJvdGF0ZWQgaW1hZ2UKICAgICAgdGhpcy5jdHhDYXJTbmFwc2hvdC5zYXZlKCk7CiAgICAgIHRoaXMuY3R4Q2FyU25hcHNob3QuY2xlYXJSZWN0KCAwLCAwLCB0aGlzLmN0eENhclNuYXBzaG90LmNhbnZhcy53aWR0aCwgdGhpcy5jdHhDYXJTbmFwc2hvdC5jYW52YXMuaGVpZ2h0ICk7CiAgICAgIHRoaXMuY3R4Q2FyU25hcHNob3QudHJhbnNsYXRlKCB0aGlzLmN0eENhclNuYXBzaG90LmNhbnZhcy53aWR0aC8yLCB0aGlzLmN0eENhclNuYXBzaG90LmNhbnZhcy5oZWlnaHQvMiApOwogICAgICB0aGlzLmN0eENhclNuYXBzaG90LnJvdGF0ZSggLXRoaXMuY2FyLmFuZ2xlICk7CiAgICAgIHRoaXMuY3R4Q2FyU25hcHNob3QudHJhbnNsYXRlKCAtdGhpcy5jdHhDYXJTbmFwc2hvdC5jYW52YXMud2lkdGgvMiwgLXRoaXMuY3R4Q2FyU25hcHNob3QuY2FudmFzLmhlaWdodC8yICk7CiAgICAgIGZvciggbGV0IHkgPSAwOyB5IDwgdGhpcy5jdHhDYXJTbmFwc2hvdC5jYW52YXMuaGVpZ2h0OyB5KysgKSB7CiAgICAgICAgZm9yKCBsZXQgeCA9IDA7IHggPCB0aGlzLmN0eENhclNuYXBzaG90LmNhbnZhcy53aWR0aDsgeCsrICkgewogICAgICAgICAgY29uc3QgcGl4ZWxJbmRleCA9IHkqdGhpcy5jdHhDYXJTbmFwc2hvdC5jYW52YXMud2lkdGggKyB4OwogICAgICAgICAgY29uc3QgY29sb3IgPSB0aGlzLnJnYlRvSGV4KCBjYXJTbmFwc2hvdFBpeGVsc1twaXhlbEluZGV4XVswXSwgY2FyU25hcHNob3RQaXhlbHNbcGl4ZWxJbmRleF1bMV0sIGNhclNuYXBzaG90UGl4ZWxzW3BpeGVsSW5kZXhdWzJdICk7CiAgICAgICAgICB0aGlzLmN0eENhclNuYXBzaG90LmZpbGxTdHlsZSA9IGNvbG9yOwogICAgICAgICAgdGhpcy5jdHhDYXJTbmFwc2hvdC5maWxsUmVjdCggeCwgeSwgMS41LCAxLjUgKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgdGhpcy5jdHhDYXJTbmFwc2hvdC5yZXN0b3JlKCk7CiAgICAgIC8vIGdldCBjYXIgaW1hZ2UKICAgICAgdGhpcy5pbWdXaGVyZUNhcklzID0gdGhpcy5jdHhDYXJTbmFwc2hvdC5nZXRJbWFnZURhdGEoIHRoaXMuY3R4Q2FyU25hcHNob3QuY2FudmFzLndpZHRoLzIgLSB0aGlzLmN0eENhci5jYW52YXMud2lkdGgvMiwgdGhpcy5jdHhDYXJTbmFwc2hvdC5jYW52YXMuaGVpZ2h0LzIgLSB0aGlzLmN0eENhci5jYW52YXMuaGVpZ2h0LzIsIHRoaXMuY3R4Q2FyLmNhbnZhcy53aWR0aCwgdGhpcy5jdHhDYXIuY2FudmFzLmhlaWdodCApOwogICAgICB0aGlzLmN0eENhci5wdXRJbWFnZURhdGEodGhpcy5pbWdXaGVyZUNhcklzLCAwLCAwKTsKCgoKICAgICAgdGhpcy5kcmF3Q2FyQW5kVmlld1NxdWFyZSgpOwoKCiAgICAgIC8vIHJlYWQgcGl4ZWxzCiAgICAgIGxldCB0b3RhbFIgPSAwOwogICAgICBsZXQgdG90YWxHID0gMDsKICAgICAgbGV0IHRvdGFsQiA9IDA7CiAgICAgIGZvciggbGV0IGkgPSAwOyBpIDwgdGhpcy5pbWdXaGVyZUNhcklzLmRhdGEubGVuZ3RoOyBpICs9IDQgKSB7CiAgICAgICAgdG90YWxSICs9IHRoaXMuaW1nV2hlcmVDYXJJcy5kYXRhW2ldOwogICAgICAgIHRvdGFsRyArPSB0aGlzLmltZ1doZXJlQ2FySXMuZGF0YVtpKzFdOwogICAgICAgIHRvdGFsQiArPSB0aGlzLmltZ1doZXJlQ2FySXMuZGF0YVtpKzJdOwogICAgICB9CiAgICAgIHRvdGFsUiA9IE1hdGgucm91bmQoIHRvdGFsUiAvICh0aGlzLmltZ1doZXJlQ2FySXMuZGF0YS5sZW5ndGggLzQpICk7CiAgICAgIHRvdGFsRyA9IE1hdGgucm91bmQoIHRvdGFsRyAvICh0aGlzLmltZ1doZXJlQ2FySXMuZGF0YS5sZW5ndGggLzQpICk7CiAgICAgIHRvdGFsQiA9IE1hdGgucm91bmQoIHRvdGFsQiAvICh0aGlzLmltZ1doZXJlQ2FySXMuZGF0YS5sZW5ndGggLzQpICk7CiAgICAgIGlmKCB0b3RhbFIgKyB0b3RhbEcgKyB0b3RhbEIgPCA3NjAgKSB7CiAgICAgICAgY29uc29sZS5sb2coImNvbGxpc2lvbiEiKTsKCiAgICAgICAgdGhpcy52aWV3UGl4ZWxzID0gbnVsbDsKICAgICAgICB0aGlzLmNhci5zdGVlcmluZyA9IHVuZGVmaW5lZDsKICAgICAgICB0aGlzLnJlc2V0Q2FyKCk7CgogICAgICAgIGlmKCB0aGlzLmhpZ2hzY29yZXMubGVuZ3RoIDwgdGhpcy5oaWdoc2NvcmVzTWF4TGVuZ3RoIHx8IHRoaXMuc2NvcmUgPiB0aGlzLmhpZ2hzY29yZXNbdGhpcy5oaWdoc2NvcmVzTWF4TGVuZ3RoLTFdLnNjb3JlICkgewogICAgICAgICAgY29uc29sZS5sb2coIm5ldyBoaWdoc2NvcmUiKTsKCiAgICAgICAgICB0aGlzLmhpZ2hzY29yZXMucHVzaCggewogICAgICAgICAgICBzY29yZTogdGhpcy5zY29yZSwKICAgICAgICAgICAgc2FtcGxlczogWy4uLnRoaXMuc2FtcGxlc10sCiAgICAgICAgICAgIG1vZGVsSW5kZXg6IHRoaXMubW9kZWxJbmRleAogICAgICAgICAgfSApOwogICAgICAgICAgdGhpcy5oaWdoc2NvcmVzLnNvcnQoZnVuY3Rpb24oYSwgYil7cmV0dXJuIGIuc2NvcmUgLSBhLnNjb3JlfSk7CiAgICAgICAgICB0aGlzLmhpZ2hzY29yZXMgPSB0aGlzLmhpZ2hzY29yZXMuc2xpY2UoMCx0aGlzLmhpZ2hzY29yZXNNYXhMZW5ndGgpOwogICAgICAgIH0KICAgICAgICBjb25zb2xlLmxvZygidHJhaW4iKTsKICAgICAgICB0aGlzLnRyYWluKCk7CgogICAgICAgIHRoaXMuZHJhd1N0YXRzKCk7CgogICAgICAgIHRoaXMuc2FtcGxlcyA9IFtdOwogICAgICAgIHRoaXMubGFzdFNjb3JlID0gdGhpcy5zY29yZTsKICAgICAgICB0aGlzLnNjb3JlID0gMDsKCiAgICAgICAgLy90aGlzLnJlZnJlc2hMb29wID0gbnVsbDsKICAgICAgfQogICAgICBlbHNlIHsKICAgICAgICB0aGlzLnNjb3JlKys7CiAgICAgICAgdGhpcy5kcmF3U3RhdHMoKTsKICAgICAgfQogICAgfSwKICAgIGRyYXdDYXJBbmRWaWV3U3F1YXJlKCkgewogICAgICAvLyBkcmF3IGNhcgogICAgICB0aGlzLmN0eC5zYXZlKCk7CiAgICAgIHRoaXMuY3R4LnRyYW5zbGF0ZSggdGhpcy5jYXIueCwgdGhpcy5jYXIueSApOwogICAgICB0aGlzLmN0eC5yb3RhdGUoIHRoaXMuY2FyLmFuZ2xlICk7CiAgICAgIHRoaXMuY3R4LnRyYW5zbGF0ZSggLXRoaXMuY2FyLngsIC10aGlzLmNhci55ICk7CiAgICAgIHRoaXMuY3R4LmZpbGxSZWN0KCB0aGlzLmNhci54IC10aGlzLmNhci53aWR0aC8yLCB0aGlzLmNhci55IC10aGlzLmNhci5sZW5ndGgvMiwgdGhpcy5jYXIud2lkdGgsIHRoaXMuY2FyLmxlbmd0aCApOwogICAgICB0aGlzLmN0eC5yZXN0b3JlKCk7CgogICAgICAvLyBkcmF3IHZpZXcgcmVjdAogICAgICB0aGlzLmN0eC5zYXZlKCk7CiAgICAgIHRoaXMuY3R4LnRyYW5zbGF0ZSggdGhpcy5jYXIudmlld1gsIHRoaXMuY2FyLnZpZXdZICk7CiAgICAgIHRoaXMuY3R4LnJvdGF0ZSggdGhpcy5jYXIuYW5nbGUgKTsKICAgICAgdGhpcy5jdHgudHJhbnNsYXRlKCAtdGhpcy5jYXIudmlld1gsIC10aGlzLmNhci52aWV3WSApOwogICAgICB0aGlzLmN0eC5zdHJva2VTdHlsZSA9ICIjZmYwMDAwIjsKICAgICAgdGhpcy5jdHguYmVnaW5QYXRoKCk7CiAgICAgIHRoaXMuY3R4LnJlY3QoIHRoaXMuY2FyLnZpZXdYIC10aGlzLmN0eFZpZXcuY2FudmFzLndpZHRoLzIsIHRoaXMuY2FyLnZpZXdZIC10aGlzLmN0eFZpZXcuY2FudmFzLmhlaWdodC8yLCB0aGlzLmN0eFZpZXcuY2FudmFzLndpZHRoLCB0aGlzLmN0eFZpZXcuY2FudmFzLmhlaWdodCApOwogICAgICB0aGlzLmN0eC5zdHJva2UoKTsKICAgICAgdGhpcy5jdHgucmVzdG9yZSgpOwogICAgfSwKICAgIGNvbXBvbmVudFRvSGV4KGMpIHsKICAgICAgdmFyIGhleCA9IGMudG9TdHJpbmcoMTYpOwogICAgICByZXR1cm4gaGV4Lmxlbmd0aCA9PSAxID8gIjAiICsgaGV4IDogaGV4OwogICAgfSwKICAgIHJnYlRvSGV4KHIsIGcsIGIpIHsKICAgICAgcmV0dXJuICIjIiArIHRoaXMuY29tcG9uZW50VG9IZXgocikgKyB0aGlzLmNvbXBvbmVudFRvSGV4KGcpICsgdGhpcy5jb21wb25lbnRUb0hleChiKTsKICAgIH0sCiAgICByZWR1Y2VQaXhlbHMocGl4ZWxzLHNpemUpIHsKICAgICAgLy8gcmVkdWNlIHJlc29sdXRpb24KICAgICAgbGV0IHBpeGVsc1JlZHVjZWQgPSBbXTsKICAgICAgZm9yKCBsZXQgeSA9IDA7IHkgPCBzaXplOyB5Kz0yICkgewogICAgICAgIGZvciggbGV0IHggPSAwOyB4IDwgc2l6ZTsgeCs9MiApIHsKICAgICAgICAgIGNvbnN0IHBpeGVsSW5kZXhlcyA9IFsKICAgICAgICAgICAgeSpzaXplICsgeCwKICAgICAgICAgICAgeSpzaXplICsgeCArMSwKICAgICAgICAgICAgKHkrMSkqc2l6ZSArIHgsCiAgICAgICAgICAgICh5KzEpKnNpemUgKyB4ICsxLAogICAgICAgICAgXTsKCiAgICAgICAgICBsZXQgdG90YWxSID0gMDsKICAgICAgICAgIGxldCB0b3RhbEcgPSAwOwogICAgICAgICAgbGV0IHRvdGFsQiA9IDA7CiAgICAgICAgICBmb3IoIGxldCBpID0gMDsgaSA8IHBpeGVsSW5kZXhlcy5sZW5ndGg7IGkrKyApIHsKICAgICAgICAgICAgdG90YWxSICs9IHBpeGVsc1twaXhlbEluZGV4ZXNbaV1dWzBdOwogICAgICAgICAgICB0b3RhbEcgKz0gcGl4ZWxzW3BpeGVsSW5kZXhlc1tpXV1bMV07CiAgICAgICAgICAgIHRvdGFsQiArPSBwaXhlbHNbcGl4ZWxJbmRleGVzW2ldXVsyXTsKICAgICAgICAgIH0KICAgICAgICAgIHRvdGFsUiA9IE1hdGgucm91bmQoIHRvdGFsUiAvIHBpeGVsSW5kZXhlcy5sZW5ndGggKTsKICAgICAgICAgIHRvdGFsRyA9IE1hdGgucm91bmQoIHRvdGFsRyAvIHBpeGVsSW5kZXhlcy5sZW5ndGggKTsKICAgICAgICAgIHRvdGFsQiA9IE1hdGgucm91bmQoIHRvdGFsQiAvIHBpeGVsSW5kZXhlcy5sZW5ndGggKTsKICAgICAgICAgIHBpeGVsc1JlZHVjZWQucHVzaCggW3RvdGFsUix0b3RhbEcsdG90YWxCXSApOwogICAgICAgIH0KICAgICAgfQogICAgICByZXR1cm4gcGl4ZWxzUmVkdWNlZDsKICAgIH0sCiAgICBkcmF3V29ybGQoKSB7CiAgICAgIHRoaXMuY3R4LmNsZWFyUmVjdCggMCwgMCwgdGhpcy5jdHguY2FudmFzLndpZHRoLCB0aGlzLmN0eC5jYW52YXMuaGVpZ2h0ICk7CiAgICAgIHRoaXMuY3R4LmRyYXdJbWFnZSggdGhpcy5pbWdXb3JsZCwgMCwgMCwgdGhpcy5jdHguY2FudmFzLndpZHRoLCB0aGlzLmN0eC5jYW52YXMuaGVpZ2h0ICk7CiAgICB9LAogICAgcmVzZXRDYXIoKSB7CiAgICAgIGNvbnNvbGUubG9nKCAicmVzZXQgY2FyIik7CiAgICAgIHRoaXMuY2FyLnggPSB0aGlzLndvcmxkV2lkdGggLyAyICogMC4yNTsKICAgICAgdGhpcy5jYXIueSA9IHRoaXMud29ybGRIZWlnaHQgLyAyICogMS41OwogICAgICB0aGlzLmNhci5hbmdsZSA9IDA7CiAgICB9LAogICAgLyoKICAgIGtleURvd24oZSkgewogICAgICBpZiggZS5jb2RlID09PSAiQXJyb3dMZWZ0IiApIHsKICAgICAgICB0aGlzLmNhci5zdGVlcmluZyA9IDA7CiAgICAgIH0KICAgICAgZWxzZSBpZiggZS5jb2RlID09PSAiQXJyb3dSaWdodCIgKSB7CiAgICAgICAgdGhpcy5jYXIuc3RlZXJpbmcgPSAxOwogICAgICB9CiAgICB9LAogICAga2V5VXAoZSkgewogICAgICBpZiggZS5jb2RlID09PSAiQXJyb3dMZWZ0IiApIHsKICAgICAgICB0aGlzLmNhci5zdGVlcmluZyA9IHVuZGVmaW5lZDsKICAgICAgfQogICAgICBlbHNlIGlmKCBlLmNvZGUgPT09ICJBcnJvd1JpZ2h0IiApIHsKICAgICAgICB0aGlzLmNhci5zdGVlcmluZyA9IHVuZGVmaW5lZDsKICAgICAgfQogICAgfQogICAgKi8KICB9Cn0K"},{"version":3,"sources":["App.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAwDA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"App.vue","sourceRoot":"src","sourcesContent":["<template>\n  <div id=\"app\">\n    <div class=\"world\">\n      <canvas class=\"world-canvas\" ref=\"canvas\" :width=\"worldWidth\" :height=\"worldHeight\"></canvas>\n      <div class=\"training\" v-if=\"training\"><span>TRAINING<br>{{trainingProgress}}% ({{trainingSamples.length}})</span></div>\n    </div>\n    <canvas class=\"car-snapshot-canvas\" ref=\"carSnapshotCanvas\" :width=\"car.length*1.5\" :height=\"car.length*1.5\"></canvas>\n    <canvas class=\"view-snapshot-canvas\" ref=\"viewSnapshotCanvas\" :width=\"viewSize*1.5\" :height=\"viewSize*1.5\"></canvas>\n    <canvas class=\"car-canvas\" ref=\"carCanvas\" :width=\"car.width\" :height=\"car.length\"></canvas>\n    <canvas class=\"view-canvas\" ref=\"viewCanvas\" :width=\"viewSize\" :height=\"viewSize\"></canvas>\n    <canvas class=\"view-canvas-reduced\" ref=\"viewCanvasReduced\" :width=\"reducedViewSize\" :height=\"reducedViewSize\"></canvas>\n    <span class=\"fps\">{{ fps }} fps</span>\n    <div class=\"highscores\">\n      <div class=\"duration\">\n        <label>Total Duration</label>\n        {{durationString}}\n      </div>\n      <label>Highscores ({{highscores.length}})</label>\n      <ul>\n        <li v-for=\"(highscore,index) in highscoresShown\" :key=\"index\"><b>{{models[highscore.modelIndex].name}} - </b> {{highscore.score}}</li>\n        <!-- <li v-if=\"highscores.length\">last: {{highscores[highscores.length-1].score}}</li> -->\n      </ul>\n    </div>\n    <div class=\"score\">\n      <div class=\"current\">\n        <label>Current Score</label>\n        {{score}}\n      </div>\n      <div class=\"last\">\n        <label>Last Score</label>\n        {{lastScore}}\n      </div>\n    </div>\n    <div class=\"stats\">\n      <canvas class=\"stats-canvas\" ref=\"statsCanvas\" :width=\"40\" :height=\"500\"></canvas>\n    </div>\n    <div class=\"models\">\n      <label>Drivers</label>\n      <ul>\n        <li v-for=\"(model,index) in models\" :key=\"index\" :class=\"{'active':index === modelIndex}\">\n          <template v-if=\"model\">\n            {{ model.name }}\n            <span class=\"layers\">\n              [\n              <template v-for=\"(layer) in model.layers\">{{layer.units}} {{layer.activation}}, </template>\n              ]\n            </span>{{model.highscore||\"–\"}} (t: {{model.trainings}})\n          </template>\n        </li>\n      </ul>\n    </div>\n  </div>\n</template>\n\n<script>\n\nconst tf = require('@tensorflow/tfjs');\n\nexport default {\n  name: 'App',\n  data() {\n    return {\n      ctx: null,\n      worldWidth: 256,\n      worldHeight: 256,\n      imgWorld: null,\n      worldLoaded: false,\n      fps: null,\n      fpsCounter: null,\n      tick: true,\n      tickTime: null,\n      duration: -1,\n      durationString: null,\n      car: {\n        width: 8,\n        length: 16,\n        x: 256 / 2 * 0.25,\n        y: 256 / 2 * 1.5,\n        speed: 0.5,\n        steeringSpeed: 0.025,\n        angle: 0\n      },\n      viewSize: 32,\n      viewReduction: 4,\n      viewReducedSize: null,\n      viewPixels: null,\n      steering: null,\n      samples: [],\n      samplesMaxLength: 4096,\n      trainingSamples: null,\n      trainingSamplesMaxLength: 4096,\n      badRewards: 0,\n      badRewardsInARow: 0,\n      score: 0,\n      lastScore: null,\n      highscores: [],\n      highscoresMaxLength: 10,\n      highscoresMaxShown: 10,\n      training: false,\n      trainingProgress: 0,\n      models: undefined,\n      numberOfModels: 5,\n      modelIndex: 0\n    }\n  },\n  computed: {\n    reducedViewSize() {\n      let reducedSize = this.viewSize;\n      for( let i = 0; i < this.viewReduction; i++ ) {\n        reducedSize = reducedSize / 2;\n      }\n      return reducedSize;\n    },\n    highscoresShown() {\n      return this.highscores.slice(0,this.highscoresMaxShown);\n    }\n  },\n  mounted() {\n    this.ctx = this.$refs.canvas.getContext(\"2d\");\n    this.imgWorld = new Image(this.worldWidth,this.worldHeight);\n    this.imgWorld.src = require('/src/assets/world4.jpg');\n    const app = this;\n    this.imgWorld.onload = function() {\n      app.worldLoaded = true;\n    }\n    //document.addEventListener('keydown', this.keyDown);\n    //document.addEventListener('keyup', this.keyUp);\n\n    this.ctxViewSnapshot = this.$refs.viewSnapshotCanvas.getContext(\"2d\");\n    this.ctxCarSnapshot = this.$refs.carSnapshotCanvas.getContext(\"2d\");\n\n    this.ctxCar = this.$refs.carCanvas.getContext(\"2d\");\n    this.ctxView = this.$refs.viewCanvas.getContext(\"2d\");\n    this.ctxViewReduced = this.$refs.viewCanvasReduced.getContext(\"2d\");\n\n    this.ctxStats = this.$refs.statsCanvas.getContext(\"2d\");\n\n\n    this.viewReducedSize = this.viewSize;\n    for( let i = 0; i < this.viewReduction; i++ ) {\n      this.viewReducedSize = this.viewReducedSize / 2;\n    }\n\n    this.models = new Array(this.numberOfModels);\n    this.createModel(this.modelIndex);\n\n    this.refreshLoop();\n  },\n  methods: {\n    createModel( modelIndex ) {\n      console.log(\"creating model ...\");\n      const numberOfLayers =  2;\n      let layers = new Array( numberOfLayers );\n      for( let i = numberOfLayers-1; i >= 0; i-- ) {\n        if( i === numberOfLayers-1 ) {\n          // last layer\n          layers[i] = {\n            units: 1,\n            activation: \"sigmoid\"\n          };\n        }\n        else {\n          layers[i] = {\n            units: 3 + Math.ceil( Math.random()*15 ),\n            activation: [\"relu\",\"sigmoid\"][Math.round(Math.random())]\n          };\n        }\n      }\n      this.models[modelIndex] = {\n        layers: layers,\n        trainings: 0,\n        highscore: undefined,\n        name: modelIndex+1,\n        children: 0\n      };\n\n      // create model with layers\n      this.models[modelIndex].model = tf.sequential();\n      for( let i = 0; i < layers.length; i++ ) {\n        if( i === 0 ) {\n          // first layer\n          this.models[modelIndex].model.add(tf.layers.dense({inputShape: this.viewReducedSize*this.viewReducedSize, activation: layers[i].activation, units: layers[i].units}));\n        }\n        else {\n          this.models[modelIndex].model.add(tf.layers.dense({activation: layers[i].activation, units: layers[i].units}));\n        }\n      }\n      /*\n      this.models[i].model.add(tf.layers.dense({inputShape: this.viewReducedSize*this.viewReducedSize, activation: \"relu\", units: 10}));\n      this.models[i].model.add(tf.layers.dense({activation: \"relu\", units: 5}));\n      this.models[i].model.add(tf.layers.dense({activation: \"sigmoid\", units: 1}));\n      */\n      //this.models[i].add(tf.layers.dense({activation: \"relu\", units: 1}));\n      this.models[modelIndex].model.compile({loss:'binaryCrossentropy',optimizer:tf.train.rmsprop(0.1),metrics:['accuracy']});\n      //this.model.compile({loss:'categoricalCrossentropy',optimizer:tf.train.adam(),metrics:['accuracy']});\n    },\n    async train() {\n\n      // check if new highscore:\n      let highscoreOfModel = this.highscores.find(el => el.modelIndex === this.modelIndex );\n      if( highscoreOfModel ) {\n        this.models[this.modelIndex].highscore = highscoreOfModel.score;\n      }\n\n      // switch to next model\n      this.modelIndex = (this.modelIndex +1) % this.numberOfModels;\n\n      // create or make clone, if necessary\n      if( !this.models[this.modelIndex] ) {\n        this.createModel(this.modelIndex);\n      }\n      else {\n        // check for new highscore\n        let highscoreOfModel = this.highscores.find(el => el.modelIndex === this.modelIndex );\n        if( !highscoreOfModel ) {\n          // replace model\n\n          let random = Math.random();\n          let highscoreIndex;\n          if( random > 1-0.182 ) {\n            highscoreIndex = 0;\n          }\n          else if( random > 1 - 0.182 - 0.163) {\n            highscoreIndex = 1;\n          }\n          else if( random > 1 - 0.182 - 0.163 - 0.146 ) {\n            highscoreIndex = 2;\n          }\n          else if( random > 1 - 0.182 - 0.163 - 0.146 - 0.127 ) {\n            highscoreIndex = 3;\n          }\n          else if( random > 1 - 0.182 - 0.163 - 0.146 - 0.127 - 0.109 ) {\n            highscoreIndex = 4;\n          }\n          else if( random > 1 - 0.182 - 0.163 - 0.146 - 0.127 - 0.109 - 0.091 ) {\n            highscoreIndex = 5;\n          }\n          else if( random > 1 - 0.182 - 0.163 - 0.146 - 0.127 - 0.109 - 0.091 - 0.073 ) {\n            highscoreIndex = 6;\n          }\n          else if( random > 1 - 0.182 - 0.163 - 0.146 - 0.127 - 0.109 - 0.091 - 0.073 - 0.054 ) {\n            highscoreIndex = 7;\n          }\n          else if( random > 1 - 0.182 - 0.163 - 0.146 - 0.127 - 0.109 - 0.091 - 0.073 - 0.054 - 0.037 ) {\n            highscoreIndex = 8;\n          }\n          else if( random > 1 - 0.182 - 0.163 - 0.146 - 0.127 - 0.109 - 0.091 - 0.073 - 0.054 - 0.037 - 0.018 ) {\n            highscoreIndex = 9;\n          }\n\n          const mother = this.models[ this.highscores[highscoreIndex].modelIndex ];\n          this.models[this.modelIndex] = {...mother};\n          this.models[this.modelIndex].trainings = 0;\n          this.models[this.modelIndex].highscore = undefined;\n          mother.children++;\n          this.models[this.modelIndex].name = mother.name+\".\"+mother.children;\n        }\n\n      }\n\n      this.training = true;\n\n      this.trainingSamples = [];\n      for( let i = 0; i < this.highscores.length; i++ ) {\n        let samples = [];\n        for( let j = 0; j < this.highscores[i].samples.length; j++ ) {\n          if( this.highscores[i].samples[j].reward > 0.5 ) {\n            // use only good rewards\n            samples.push( this.highscores[i].samples[j] );\n          }\n        }\n        this.trainingSamples.push(...samples);\n      }\n      // randomise and slice\n      this.trainingSamples.sort(function(){return 0.5 - Math.random()});\n      this.trainingSamples = this.trainingSamples.slice(0,this.trainingSamplesMaxLength);\n\n      console.log(\"total number of samples: \"+this.trainingSamples.length);\n\n      let featureValuesTraining = [];\n      let labelValuesTraining = [];\n      for( let i = 0; i < this.trainingSamples.length; i++ ) {\n        let featureValueTraining = [...this.trainingSamples[i].state];\n        //featureValueTraining.push( this.trainingSamples[i].reward );\n        featureValuesTraining.push( featureValueTraining );\n        labelValuesTraining.push( this.trainingSamples[i].action );\n      }\n      const featureTensorTraining = tf.tensor2d( featureValuesTraining, [featureValuesTraining.length, featureValuesTraining[0].length] );\n      const labelTensorTraining = tf.tensor2d( labelValuesTraining, [labelValuesTraining.length, 1] );\n\n      console.log(\"train model ...\");\n      await this.trainModel( this.modelIndex, featureTensorTraining, labelTensorTraining, Math.min(10, this.trainingSamplesMaxLength/this.trainingSamples.length)*10 );\n\n      this.training = false;\n      this.trainingProgress = 0;\n\n      this.models[this.modelIndex].trainings += 1;\n    },\n    async trainModel( modelIndex, featureTensorTraining, labelTensorTraining, epochs ) {\n      const ref = this;\n      return this.models[modelIndex].model.fit( featureTensorTraining, labelTensorTraining, {\n        epochs,\n        //validationSplit: 0.2,\n        callbacks: {\n          onEpochEnd: function(epoch) {\n            ref.trainingProgress = Math.round( epoch / epochs * 100 );\n          },\n          onTrainEnd: function() {\n            console.log(\"done\");\n          }\n        }\n      });\n    },\n    async predict( modelIndex, input ) {\n      return tf.tidy( () => {\n        const inputTensor = tf.tensor2d([input],[1, this.viewReducedSize*this.viewReducedSize]);\n        const outputTensor = this.models[modelIndex].model.predict( inputTensor );\n        const outputValue = outputTensor.dataSync();\n\n        return outputValue;\n      });\n    },\n    async getSteering() {\n      this.prediction = await this.predict( this.modelIndex, this.testingDataInput );\n      this.prediction = Math.max( 0, this.prediction  )\n      return this.prediction;\n    },\n    refreshLoop() {\n      window.requestAnimationFrame(() => {\n        const now = performance.now();\n        if( this.tick ) {\n          this.tickTime = now;\n          this.fps = this.fpsCounter;\n          this.fpsCounter = 0;\n          this.tick = false;\n\n          this.duration++;\n          const date = new Date(0);\n          date.setSeconds(this.duration); // specify value for SECONDS here\n          this.durationString = date.toISOString().substr(11, 8);\n        }\n        else {\n          this.fpsCounter++;\n          if( now >= this.tickTime + 1000 ) {\n            this.tick = true;\n          }\n        }\n\n        this.enterFrame();\n\n        this.refreshLoop();\n      });\n    },\n    enterFrame() {\n      if( this.worldLoaded && !this.training ) {\n        this.drawWorld();\n        this.getView();\n        this.moveCar();\n      }\n    },\n    drawStats() {\n      this.ctxStats.clearRect( 0, 0, this.ctxStats.canvas.width, this.ctxStats.canvas.height );\n      //this.ctxStats.fillRect(0, 0, this.ctxStats.canvas.width, this.ctxStats.canvas.height);\n      //this.ctxStats.strokeStyle = \"#ffffff\";\n      const numberOfsamplesDrawn = Math.min(512, this.samples.length);\n      for( let i = 0; i < numberOfsamplesDrawn; i++ ) {\n        /*\n        this.ctxStats.moveTo( this.samples[i].action * this.ctxStats.canvas.width, this.ctxStats.canvas.height/this.samples.length * i );\n        this.ctxStats.lineTo( this.samples[i+1].action * this.ctxStats.canvas.width, this.ctxStats.canvas.height/this.samples.length * (i+1) );\n        */\n        this.ctxStats.beginPath();\n        this.ctxStats.fillStyle = \"#ffffff\";\n        this.ctxStats.arc(this.samples[i].actionPredicted * this.ctxStats.canvas.width, this.ctxStats.canvas.height/numberOfsamplesDrawn * i, 1, 0, 2 * Math.PI);\n        this.ctxStats.fill();\n\n        this.ctxStats.beginPath();\n        let rgb;\n        if( this.samples[i].reward >= 0.5 ) {\n          //rgb = \"#00ff00\";\n          rgb = \"#00\"+ Math.round( this.samples[i].reward * 255 ).toString(16) + \"00\";\n          this.ctxStats.fillStyle = rgb;\n          this.ctxStats.arc(this.samples[i].action * this.ctxStats.canvas.width, this.ctxStats.canvas.height/numberOfsamplesDrawn * i, 1, 0, 2 * Math.PI);\n          this.ctxStats.fill();\n        }\n        else {\n          //rgb = \"#ff0000\";\n          rgb = \"#\"+ Math.round( (1-this.samples[i].reward) * 255 ).toString(16) + \"0000\";\n          this.ctxStats.fillStyle = rgb;\n          this.ctxStats.arc(this.samples[i].action * this.ctxStats.canvas.width, this.ctxStats.canvas.height/numberOfsamplesDrawn * i, 1, 0, 2 * Math.PI);\n          this.ctxStats.fill();\n        }\n      }\n      //this.ctxStats.stroke();\n    },\n    moveCar() {\n      this.testingDataInput = [...this.viewPixels];\n      //this.testingDataInput.push(1.0);\n      const ref = this;\n      this.getSteering().then( function(value) {\n        //console.log(\"predicted steering: \"+value);\n        value = Math.min( value, 1 );\n        value = Math.max( value, 0 );\n        //console.log(\"predicted steering: \"+value);\n        ref.car.steeringPredicted = value;\n\n        let randomisation = 0;\n        if( ref.samples[0] ) {\n          if( ref.samples[0].reward < 0.5 ) {\n            randomisation = Math.min( 1, (ref.badRewards/ref.samples.length) * ref.badRewardsInARow );\n          }\n          else {\n            randomisation = 0.05;\n          }\n        }\n        else {\n\n          randomisation = 1;\n        }\n\n        //console.log(\"randomisation: \"+randomisation);\n        const random = Math.random();\n        let randomisedValue = value - randomisation*1 + random * randomisation*2;\n        randomisedValue = Math.min( randomisedValue, 1 );\n        randomisedValue = Math.max( randomisedValue, 0 );\n        ref.car.steering = randomisedValue;\n        //console.log(\"new steering: \"+randomisedValue);\n\n        if( ref.car.steering < 0.5 ) {\n          // left\n          const steeringStrength = (0.5 - ref.car.steering) * 2\n          ref.car.angle -= ref.car.steeringSpeed * steeringStrength;\n        }\n        else if( ref.car.steering > 0.5 ){\n          // right\n          const steeringStrength = (ref.car.steering - 0.5) * 2\n          ref.car.angle += ref.car.steeringSpeed * steeringStrength;\n        }\n\n        ref.car.x += Math.sin( ref.car.angle ) *ref.car.speed;\n        ref.car.y -= Math.cos( ref.car.angle ) *ref.car.speed;\n\n        ref.checkCarCollision();\n      });\n    },\n    getView() {\n      // view\n      this.car.viewX = this.car.x + Math.sin( this.car.angle ) * (this.car.length*0+this.viewSize/2);\n      this.car.viewY = this.car.y - Math.cos( this.car.angle ) * (this.car.length*0+this.viewSize/2);\n      // get view image\n      this.snapshotWhereViewIs = this.ctx.getImageData( this.car.viewX - this.ctxViewSnapshot.canvas.width/2, this.car.viewY - this.ctxViewSnapshot.canvas.height/2, this.ctxViewSnapshot.canvas.width, this.ctxViewSnapshot.canvas.height );\n      // read pixels\n      let viewSnapshotPixels = [];\n      for( let i = 0; i < this.snapshotWhereViewIs.data.length; i += 4 ) {\n        const r = this.snapshotWhereViewIs.data[i];\n        const g = this.snapshotWhereViewIs.data[i+1];\n        const b = this.snapshotWhereViewIs.data[i+2];\n        viewSnapshotPixels.push( [r,g,b] );\n      }\n      // draw rotated image\n      this.ctxViewSnapshot.save();\n      this.ctxViewSnapshot.clearRect( 0, 0, this.ctxViewSnapshot.canvas.width, this.ctxViewSnapshot.canvas.height );\n      this.ctxViewSnapshot.translate( this.ctxViewSnapshot.canvas.width/2, this.ctxViewSnapshot.canvas.height/2 );\n      this.ctxViewSnapshot.rotate( -this.car.angle );\n      this.ctxViewSnapshot.translate( -this.ctxViewSnapshot.canvas.width/2, -this.ctxViewSnapshot.canvas.height/2 );\n      for( let y = 0; y < this.ctxViewSnapshot.canvas.height; y++ ) {\n        for( let x = 0; x < this.ctxViewSnapshot.canvas.width; x++ ) {\n          const pixelIndex = y*this.ctxViewSnapshot.canvas.width + x;\n          const color = this.rgbToHex( viewSnapshotPixels[pixelIndex][0], viewSnapshotPixels[pixelIndex][1], viewSnapshotPixels[pixelIndex][2] );\n          this.ctxViewSnapshot.fillStyle = color;\n          this.ctxViewSnapshot.fillRect( x, y, 1.5, 1.5 );\n        }\n      }\n      this.ctxViewSnapshot.restore();\n      // get view image\n      this.imgWhereViewIs = this.ctxViewSnapshot.getImageData( this.ctxViewSnapshot.canvas.width/2 - this.ctxView.canvas.width/2, this.ctxViewSnapshot.canvas.height/2 - this.ctxView.canvas.height/2, this.ctxView.canvas.width, this.ctxView.canvas.height );\n      this.ctxView.putImageData(this.imgWhereViewIs, 0, 0);\n      // read pixels\n      let viewPixels = [];\n      for( let i = 0; i < this.imgWhereViewIs.data.length; i += 4 ) {\n        const r = this.imgWhereViewIs.data[i];\n        const g = this.imgWhereViewIs.data[i+1];\n        const b = this.imgWhereViewIs.data[i+2];\n        viewPixels.push( [r,g,b] );\n      }\n      let viewPixelsReduced = viewPixels;\n      for( let i = 0; i < this.viewReduction; i++ ) {\n        viewPixelsReduced = this.reducePixels( viewPixelsReduced, Math.sqrt(viewPixelsReduced.length) );\n      }\n      // draw reduced view\n      for( let y = 0; y < this.ctxViewReduced.canvas.height; y++ ) {\n        for( let x = 0; x < this.ctxViewReduced.canvas.width; x++ ) {\n          const pixelIndex = y*this.ctxViewReduced.canvas.width + x;\n          const color = this.rgbToHex( viewPixelsReduced[pixelIndex][0], viewPixelsReduced[pixelIndex][1], viewPixelsReduced[pixelIndex][2] );\n          this.ctxViewReduced.fillStyle = color;\n          this.ctxViewReduced.fillRect( x, y, 1.5, 1.5 );\n        }\n      }\n\n      let previousTotalBrightness;\n      // create sample\n      if( this.viewPixels ) {\n        // has previous state\n        this.samples.unshift( {\n          state: this.viewPixels,\n          action: this.car.steering,\n          actionPredicted: this.car.steeringPredicted\n        } );\n        //this.samples = this.samples.slice(0,this.samplesMaxLength);\n        previousTotalBrightness = this.totalBrightness;\n      }\n\n      // save new view pixels\n      this.viewPixels = [];\n      this.totalBrightness = 0;\n      for( let i = 0; i < viewPixelsReduced.length; i++ ) {\n        const brightness = (viewPixelsReduced[i][0] + viewPixelsReduced[i][1] + viewPixelsReduced[i][2]) / 765;\n        this.viewPixels.push( brightness );\n        this.totalBrightness += brightness;\n      }\n      this.totalBrightness = this.totalBrightness / this.viewPixels.length;\n\n      if( this.samples.length ) {\n        const brightnessChange = this.totalBrightness - previousTotalBrightness;\n        console.log(\"---\");\n        //console.log( \"totalBrightness: \"+ this.totalBrightness );\n        //console.log( \"previousTotalBrightness: \"+ previousTotalBrightness );\n        //console.log( \"brightnessChange: \"+ brightnessChange );\n        let reward;\n        if( brightnessChange >= 0 ) {\n          // better\n          if( this.totalBrightness > 0.5 ) {\n            // not so bad situation\n            reward = 1;\n          }\n          else {\n            // bad situation\n            reward = 0.75 + Math.min( 0.25, brightnessChange*10 * this.totalBrightness );\n          }\n          //reward = 1;\n          //console.log(reward+\": better\");\n        }\n        else {\n          // worse\n          if( this.totalBrightness < 0.5 ) {\n            // bad situation\n            reward = 0;\n          }\n          else {\n            // bad situation\n            reward = Math.min( 0.25, Math.abs(brightnessChange)*10 * this.totalBrightness );\n          }\n          reward = 0;\n          //console.log(reward+\": worse\");\n        }\n        this.samples[0].reward = reward;\n\n\n        // calculate total accuarcy\n        if( reward < 0.5 ) {\n          this.badRewards++;\n          this.badRewardsInARow++;\n        }\n        else {\n          this.badRewardsInARow = 0;\n        }\n\n\n        // trim samples:\n        if( this.samples.length === this.samplesMaxLength ) {\n          //console.log(\"max length reached: \"+this.samples.length);\n          if( this.samples[this.samples.length-1].reward < 0.5 ) {\n            //console.log(\"last is badReward\");\n            this.badRewards--;\n          }\n          //console.log(\"remove\");\n          this.samples = this.samples.slice(0,this.samplesMaxLength-1);\n          //console.log(\"new length: \" +this.samples.length);\n        }\n        console.log( \"good samples: \"+(this.samples.length-this.badRewards) +\" of \"+this.samples.length);\n\n      }\n      else {\n        // first cycle\n        this.badRewards = 0;\n        this.badRewardsInARow = 0;\n      }\n\n    },\n    checkCarCollision() {\n      // get car image\n      this.snapshotWhereCarIs = this.ctx.getImageData( this.car.x - this.ctxCarSnapshot.canvas.width/2, this.car.y - this.ctxCarSnapshot.canvas.height/2, this.ctxCarSnapshot.canvas.width, this.ctxCarSnapshot.canvas.height );\n      // read pixels\n      let carSnapshotPixels = [];\n      for( let i = 0; i < this.snapshotWhereCarIs.data.length; i += 4 ) {\n        const r = this.snapshotWhereCarIs.data[i];\n        const g = this.snapshotWhereCarIs.data[i+1];\n        const b = this.snapshotWhereCarIs.data[i+2];\n        carSnapshotPixels.push( [r,g,b] );\n      }\n      // draw rotated image\n      this.ctxCarSnapshot.save();\n      this.ctxCarSnapshot.clearRect( 0, 0, this.ctxCarSnapshot.canvas.width, this.ctxCarSnapshot.canvas.height );\n      this.ctxCarSnapshot.translate( this.ctxCarSnapshot.canvas.width/2, this.ctxCarSnapshot.canvas.height/2 );\n      this.ctxCarSnapshot.rotate( -this.car.angle );\n      this.ctxCarSnapshot.translate( -this.ctxCarSnapshot.canvas.width/2, -this.ctxCarSnapshot.canvas.height/2 );\n      for( let y = 0; y < this.ctxCarSnapshot.canvas.height; y++ ) {\n        for( let x = 0; x < this.ctxCarSnapshot.canvas.width; x++ ) {\n          const pixelIndex = y*this.ctxCarSnapshot.canvas.width + x;\n          const color = this.rgbToHex( carSnapshotPixels[pixelIndex][0], carSnapshotPixels[pixelIndex][1], carSnapshotPixels[pixelIndex][2] );\n          this.ctxCarSnapshot.fillStyle = color;\n          this.ctxCarSnapshot.fillRect( x, y, 1.5, 1.5 );\n        }\n      }\n      this.ctxCarSnapshot.restore();\n      // get car image\n      this.imgWhereCarIs = this.ctxCarSnapshot.getImageData( this.ctxCarSnapshot.canvas.width/2 - this.ctxCar.canvas.width/2, this.ctxCarSnapshot.canvas.height/2 - this.ctxCar.canvas.height/2, this.ctxCar.canvas.width, this.ctxCar.canvas.height );\n      this.ctxCar.putImageData(this.imgWhereCarIs, 0, 0);\n\n\n\n      this.drawCarAndViewSquare();\n\n\n      // read pixels\n      let totalR = 0;\n      let totalG = 0;\n      let totalB = 0;\n      for( let i = 0; i < this.imgWhereCarIs.data.length; i += 4 ) {\n        totalR += this.imgWhereCarIs.data[i];\n        totalG += this.imgWhereCarIs.data[i+1];\n        totalB += this.imgWhereCarIs.data[i+2];\n      }\n      totalR = Math.round( totalR / (this.imgWhereCarIs.data.length /4) );\n      totalG = Math.round( totalG / (this.imgWhereCarIs.data.length /4) );\n      totalB = Math.round( totalB / (this.imgWhereCarIs.data.length /4) );\n      if( totalR + totalG + totalB < 760 ) {\n        console.log(\"collision!\");\n\n        this.viewPixels = null;\n        this.car.steering = undefined;\n        this.resetCar();\n\n        if( this.highscores.length < this.highscoresMaxLength || this.score > this.highscores[this.highscoresMaxLength-1].score ) {\n          console.log(\"new highscore\");\n\n          this.highscores.push( {\n            score: this.score,\n            samples: [...this.samples],\n            modelIndex: this.modelIndex\n          } );\n          this.highscores.sort(function(a, b){return b.score - a.score});\n          this.highscores = this.highscores.slice(0,this.highscoresMaxLength);\n        }\n        console.log(\"train\");\n        this.train();\n\n        this.drawStats();\n\n        this.samples = [];\n        this.lastScore = this.score;\n        this.score = 0;\n\n        //this.refreshLoop = null;\n      }\n      else {\n        this.score++;\n        this.drawStats();\n      }\n    },\n    drawCarAndViewSquare() {\n      // draw car\n      this.ctx.save();\n      this.ctx.translate( this.car.x, this.car.y );\n      this.ctx.rotate( this.car.angle );\n      this.ctx.translate( -this.car.x, -this.car.y );\n      this.ctx.fillRect( this.car.x -this.car.width/2, this.car.y -this.car.length/2, this.car.width, this.car.length );\n      this.ctx.restore();\n\n      // draw view rect\n      this.ctx.save();\n      this.ctx.translate( this.car.viewX, this.car.viewY );\n      this.ctx.rotate( this.car.angle );\n      this.ctx.translate( -this.car.viewX, -this.car.viewY );\n      this.ctx.strokeStyle = \"#ff0000\";\n      this.ctx.beginPath();\n      this.ctx.rect( this.car.viewX -this.ctxView.canvas.width/2, this.car.viewY -this.ctxView.canvas.height/2, this.ctxView.canvas.width, this.ctxView.canvas.height );\n      this.ctx.stroke();\n      this.ctx.restore();\n    },\n    componentToHex(c) {\n      var hex = c.toString(16);\n      return hex.length == 1 ? \"0\" + hex : hex;\n    },\n    rgbToHex(r, g, b) {\n      return \"#\" + this.componentToHex(r) + this.componentToHex(g) + this.componentToHex(b);\n    },\n    reducePixels(pixels,size) {\n      // reduce resolution\n      let pixelsReduced = [];\n      for( let y = 0; y < size; y+=2 ) {\n        for( let x = 0; x < size; x+=2 ) {\n          const pixelIndexes = [\n            y*size + x,\n            y*size + x +1,\n            (y+1)*size + x,\n            (y+1)*size + x +1,\n          ];\n\n          let totalR = 0;\n          let totalG = 0;\n          let totalB = 0;\n          for( let i = 0; i < pixelIndexes.length; i++ ) {\n            totalR += pixels[pixelIndexes[i]][0];\n            totalG += pixels[pixelIndexes[i]][1];\n            totalB += pixels[pixelIndexes[i]][2];\n          }\n          totalR = Math.round( totalR / pixelIndexes.length );\n          totalG = Math.round( totalG / pixelIndexes.length );\n          totalB = Math.round( totalB / pixelIndexes.length );\n          pixelsReduced.push( [totalR,totalG,totalB] );\n        }\n      }\n      return pixelsReduced;\n    },\n    drawWorld() {\n      this.ctx.clearRect( 0, 0, this.ctx.canvas.width, this.ctx.canvas.height );\n      this.ctx.drawImage( this.imgWorld, 0, 0, this.ctx.canvas.width, this.ctx.canvas.height );\n    },\n    resetCar() {\n      console.log( \"reset car\");\n      this.car.x = this.worldWidth / 2 * 0.25;\n      this.car.y = this.worldHeight / 2 * 1.5;\n      this.car.angle = 0;\n    },\n    /*\n    keyDown(e) {\n      if( e.code === \"ArrowLeft\" ) {\n        this.car.steering = 0;\n      }\n      else if( e.code === \"ArrowRight\" ) {\n        this.car.steering = 1;\n      }\n    },\n    keyUp(e) {\n      if( e.code === \"ArrowLeft\" ) {\n        this.car.steering = undefined;\n      }\n      else if( e.code === \"ArrowRight\" ) {\n        this.car.steering = undefined;\n      }\n    }\n    */\n  }\n}\n</script>\n\n<style lang=\"scss\">\n\nbody {\n  margin: 0;\n  height: 100vh;\n  font-family: sans-serif;\n  font-size: 16px;\n  line-height: 150%;\n  background-color: black;\n  color: white;\n}\nlabel {\n  font-size: 13px;\n}\n#app {\n  height: 100%;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  margin: auto;\n  max-width: 100vh;\n}\n\n.world {\n  position: relative;\n  width: 100%;\n  height: 0;\n  padding-top: 100%;\n  .world-canvas {\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n  }\n  .training {\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    width: 20%;\n    height: 20%;\n    position: absolute;\n    top: 40%;\n    left: 40%;\n    span {\n      text-align: center;\n    }\n  }\n}\n\n\n.car-snapshot-canvas {\n  position: absolute;\n  top: 8px;\n  left: 8px;\n  border: 1px solid white;\n  image-rendering: pixelated;\n  width: 10%;\n  display: none;\n}\n.car-canvas {\n  position: absolute;\n  bottom: 8px;\n  left: 8px;\n  border: 1px solid white;\n  image-rendering: pixelated;\n  width: 15%;\n  display: none;\n}\n.view-snapshot-canvas {\n  position: absolute;\n  top: 8px;\n  right: 8px;\n  border: 1px solid white;\n  image-rendering: pixelated;\n  width: 10%;\n  display: none;\n}\n.view-canvas {\n  position: absolute;\n  bottom: 8px;\n  right: 8px;\n  border: 1px solid white;\n  image-rendering: pixelated;\n  width: 10%;\n  display: none;\n}\n.view-canvas-reduced {\n  position: absolute;\n  bottom: 8px;\n  right: 8px;\n  border: 1px solid red;\n  image-rendering: pixelated;\n  width: 15%;\n}\n\n\n\n.fps {\n  position: absolute;\n  top: 8px;\n  left: 50%;\n  color: #333333;\n}\n\n.highscores {\n  position: absolute;\n  top: 16px;\n  right: 16px;\n  text-align: right;\n\n  .duration {\n    margin-bottom: 16px;\n  }\n\n  label {\n    display: block;\n    font-weight: bold;\n    margin-bottom: 8px;\n  }\n  ul {\n    list-style: none;\n    margin: 0;\n    padding: 0;\n    li {\n      &:first-child {\n        font-size: 20px;\n        line-height: 150%;\n      }\n      &:nth-child(2),\n      &:nth-child(3) {\n        font-size: 16px;\n        line-height: 20px;\n      }\n      display: block;\n      font-size: 13px;\n      line-height: 16px;\n    }\n  }\n\n}\n\n\n.score {\n  position: absolute;\n  right: calc( 15% + 48px);\n  bottom: 48px;\n  text-align: right;\n  label {\n    display: block;\n    font-weight: bold;\n    margin-bottom: 8px;\n  }\n\n  .last {\n    margin-top: 16px;\n    font-size: 25px;\n    label {\n      font-size: 16px;\n    }\n  }\n}\n\n.stats {\n  position: absolute;\n  top: 0;\n  left: 0;\n  height: 100%;\n  .stats-canvas {\n    height: 100%;\n    border-right: 1px solid #333;\n  }\n  &:before {\n    content: '';\n    position: absolute;\n    display: block;\n    width: 50%;\n    height: 100%;\n    border-right: 1px solid #666666;\n  }\n}\n\n.models {\n  position: absolute;\n  top: 0;\n  left: 7.5%;\n  label {\n    display: block;\n    font-weight: bold;\n    margin-bottom: 8px;\n  }\n  ul {\n    list-style: none;\n    padding: 0;\n    margin: 0;\n    li {\n      color: #cccccc;\n      font-size: 13px;\n      line-height: 125%;\n      &.active {\n        font-weight: bold;\n        font-size: 25px;\n      }\n      .layers {\n        font-size: 10px;\n      }\n    }\n  }\n}\n\n</style>\n"]}]}